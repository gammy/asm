<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--from http://courses.ece.illinois.edu/ece390/books/labmanual/inst-ref-general.html -->
<html>
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org">
    <title>General Instructions</title>
    <meta name="GENERATOR" content=
    "Modular DocBook HTML Stylesheet Version 1.73 ">
    <link rel="HOME" title="January 2003 Laboratory Notes" href=
    "index.html">
    <link rel="UP" title="x86 Instruction Reference" href=
    "inst-ref.html">
    <link rel="PREVIOUS" title="Key to Instruction Flags" href=
    "inst-ref-flags.html">
    <link rel="NEXT" title="SIMD Instructions (MMX, SSE)" href=
    "inst-ref-simd.html">
    <link rel="STYLESHEET" type="text/css" href="docbook.css">
  </head>

  <body class="SECT1" bgcolor="#FFFFFF" text="#000000" link=
  "#0000FF" vlink="#840084" alink="#0000FF">
    <div class="NAVHEADER">
      <table summary="Header navigation table" width="100%" border=
      "0" cellpadding="0" cellspacing="0">
        <tr>
          <th colspan="3" align="center">January 2003 Laboratory
          Notes: Computer Engineering II</th>
        </tr>

        <tr>
          <td width="10%" align="left" valign="bottom"><a href=
          "inst-ref-flags.html" accesskey="P">Prev</a></td>

          <td width="80%" align="center" valign="bottom">Appendix
          B. x86 Instruction Reference</td>

          <td width="10%" align="right" valign="bottom"><a href=
          "inst-ref-simd.html" accesskey="N">Next</a></td>
        </tr>
      </table>
      <hr align="LEFT" width="100%">
    </div>

    <div class="SECT1">
      <h1 class="SECT1"><a name="INST-REF-GENERAL">B.4 General
      Instructions</a></h1>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-AAA">B.4.1 <tt class=
        "LITERAL">AAA</tt>, <tt class="LITERAL">AAS</tt>, <tt
        class="LITERAL">AAM</tt>, <tt class="LITERAL">AAD</tt>:
        ASCII Adjustments</a></h2>
<pre class="SCREEN">
    AAA                           ; 37                   [8086]
    
    AAS                           ; 3F                   [8086]
    
    AAD                           ; D5 0A                [8086]
    AAD imm                       ; D5 ib                [8086]
    
    AAM                           ; D4 0A                [8086]
    AAM imm                       ; D4 ib                [8086]
</pre>

        <p>These instructions are used in conjunction with the add,
        subtract, multiply and divide instructions to perform
        binary-coded decimal arithmetic in <span class=
        "emphasis"><i class="EMPHASIS">unpacked</i></span> (one BCD
        digit per byte - easy to translate to and from <tt class=
        "LITERAL">ASCII</tt>, hence the instruction names) form.
        There are also packed BCD instructions <tt class=
        "LITERAL">DAA</tt> and <tt class="LITERAL">DAS</tt>: see <a
        href="inst-ref-general.html#INST-REF-DAA">Section
        B.4.21</a>.</p>

        <ul>
          <li>
            <p><tt class="LITERAL">AAA</tt> (ASCII Adjust After
            Addition) should be used after a one-byte <tt class=
            "LITERAL">ADD</tt> instruction whose destination was
            the <tt class="REGISTER">AL</tt> register: by means of
            examining the value in the low nibble of <tt class=
            "REGISTER">AL</tt> and also the auxiliary carry flag
            <tt class="REGISTER">AF</tt>, it determines whether the
            addition has overflowed, and adjusts it (and sets the
            carry flag) if so. You can add long BCD strings
            together by doing <tt class="LITERAL">ADD</tt>/<tt
            class="LITERAL">AAA</tt> on the low digits, then doing
            <tt class="LITERAL">ADC</tt>/<tt class=
            "LITERAL">AAA</tt> on each subsequent digit.</p>
          </li>

          <li>
            <p><tt class="LITERAL">AAS</tt> (ASCII Adjust <tt
            class="REGISTER">AL</tt> After Subtraction) works
            similarly to <tt class="LITERAL">AAA</tt>, but is for
            use after <tt class="LITERAL">SUB</tt> instructions
            rather than <tt class="LITERAL">ADD</tt>.</p>
          </li>

          <li>
            <p><tt class="LITERAL">AAM</tt> (ASCII Adjust <tt
            class="REGISTER">AX</tt> After Multiply) is for use
            after you have multiplied two decimal digits together
            and left the result in <tt class="REGISTER">AL</tt>: it
            divides <tt class="REGISTER">AL</tt> by ten and stores
            the quotient in <tt class="REGISTER">AH</tt>, leaving
            the remainder in <tt class="REGISTER">AL</tt>. The
            divisor 10 can be changed by specifying an operand to
            the instruction: a particularly handy use of this is
            <tt class="LITERAL">AAM 16</tt>, causing the two
            nibbles in <tt class="REGISTER">AL</tt> to be separated
            into <tt class="REGISTER">AH</tt> and <tt class=
            "REGISTER">AL</tt>.</p>
          </li>

          <li>
            <p><tt class="LITERAL">AAD</tt> (ASCII Adjust <tt
            class="REGISTER">AX</tt> Before Division) performs the
            inverse operation to <tt class="LITERAL">AAM</tt>: it
            multiplies <tt class="REGISTER">AH</tt> by ten, adds it
            to <tt class="REGISTER">AL</tt>, and sets <tt class=
            "REGISTER">AH</tt> to zero. Again, the multiplier 10
            can be changed.</p>
          </li>
        </ul>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-ADC">B.4.2 <tt class=
        "LITERAL">ADC</tt>: Add with Carry</a></h2>
<pre class="SCREEN">
    ADC r/m8,reg8                 ; 10 /r                [8086]
    ADC r/m16,reg16               ; o16 11 /r            [8086]
    ADC r/m32,reg32               ; o32 11 /r            [386]
    
    ADC reg8,r/m8                 ; 12 /r                [8086]
    ADC reg16,r/m16               ; o16 13 /r            [8086]
    ADC reg32,r/m32               ; o32 13 /r            [386]
    
    ADC r/m8,imm8                 ; 80 /2 ib             [8086]
    ADC r/m16,imm16               ; o16 81 /2 iw         [8086]
    ADC r/m32,imm32               ; o32 81 /2 id         [386]
    
    ADC r/m16,imm8                ; o16 83 /2 ib         [8086]
    ADC r/m32,imm8                ; o32 83 /2 ib         [386]
    
    ADC AL,imm8                   ; 14 ib                [8086]
    ADC AX,imm16                  ; o16 15 iw            [8086]
    ADC EAX,imm32                 ; o32 15 id            [386]
</pre>

        <p><tt class="LITERAL">ADC</tt> performs integer addition:
        it adds its two operands together, plus the value of the
        carry flag, and leaves the result in its destination
        (first) operand. The destination operand can be a register
        or a memory location. The source operand can be a register,
        a memory locaion, or an immediate value.</p>

        <p>The flags are set according to the result of the
        operation: in particular, the carry flag is affected and
        can be used by a subsequent <tt class="LITERAL">ADC</tt>
        instruction.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>To add two numbers without also adding the contents of
        the carry flag, use <tt class="LITERAL">ADD</tt> (<a href=
        "inst-ref-general.html#INST-REF-ADD">Section
        B.4.3</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-ADD">B.4.3 <tt class=
        "LITERAL">ADD</tt>: Add Integers</a></h2>
<pre class="SCREEN">
    ADD r/m8,reg8                 ; 00 /r                [8086]
    ADD r/m16,reg16               ; o16 01 /r            [8086]
    ADD r/m32,reg32               ; o32 01 /r            [386]
    
    ADD reg8,r/m8                 ; 02 /r                [8086]
    ADD reg16,r/m16               ; o16 03 /r            [8086]
    ADD reg32,r/m32               ; o32 03 /r            [386]
    
    ADD r/m8,imm8                 ; 80 /0 ib             [8086]
    ADD r/m16,imm16               ; o16 81 /0 iw         [8086]
    ADD r/m32,imm32               ; o32 81 /0 id         [386]
    
    ADD r/m16,imm8                ; o16 83 /0 ib         [8086]
    ADD r/m32,imm8                ; o32 83 /0 ib         [386]
    
    ADD AL,imm8                   ; 04 ib                [8086]
    ADD AX,imm16                  ; o16 05 iw            [8086]
    ADD EAX,imm32                 ; o32 05 id            [386]
</pre>

        <p><tt class="LITERAL">ADD</tt> performs integer addition:
        it adds its two operands together, and leaves the result in
        its destination (first) operand. The destination operand
        can be a register or a memory location. The source operand
        can be a register, a memory location, or an immediate
        value.</p>

        <p>The flags are set according to the result of the
        operation: in particular, the carry flag is affected and
        can be used by a subsequent <tt class="LITERAL">ADC</tt>
        instruction.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-AND">B.4.4 <tt class=
        "LITERAL">AND</tt>: Bitwise AND</a></h2>
<pre class="SCREEN">
    AND r/m8,reg8                 ; 20 /r                [8086]
    AND r/m16,reg16               ; o16 21 /r            [8086]
    AND r/m32,reg32               ; o32 21 /r            [386]
    
    AND reg8,r/m8                 ; 22 /r                [8086]
    AND reg16,r/m16               ; o16 23 /r            [8086]
    AND reg32,r/m32               ; o32 23 /r            [386]
    
    AND r/m8,imm8                 ; 80 /4 ib             [8086]
    AND r/m16,imm16               ; o16 81 /4 iw         [8086]
    AND r/m32,imm32               ; o32 81 /4 id         [386]
    
    AND r/m16,imm8                ; o16 83 /4 ib         [8086]
    AND r/m32,imm8                ; o32 83 /4 ib         [386]
    
    AND AL,imm8                   ; 24 ib                [8086]
    AND AX,imm16                  ; o16 25 iw            [8086]
    AND EAX,imm32                 ; o32 25 id            [386]
</pre>

        <p><tt class="LITERAL">AND</tt> performs a bitwise AND
        operation between its two operands (i.e. each bit of the
        result is 1 if and only if the corresponding bits of the
        two inputs were both 1), and stores the result in the
        destination (first) operand. The destination operand can be
        a register or a memory location. The source operand can be
        a register, a memory location, or an immediate value.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>The <tt class="REGISTER">MMX</tt> instruction <tt class=
        "LITERAL">PAND</tt> (see <a href=
        "inst-ref-simd.html#INST-REF-PAND">Section B.5.42</a>)
        performs the same operation on the 64-bit <tt class=
        "REGISTER">MMX</tt> registers.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-ARPL">B.4.5 <tt class=
        "LITERAL">ARPL</tt>: Adjust RPL Field of Selector</a></h2>
<pre class="SCREEN">
    ARPL r/m16,reg16              ; 63 /r                [286,PRIV]
</pre>

        <p><tt class="LITERAL">ARPL</tt> expects its two word
        operands to be segment selectors. It adjusts the <tt class=
        "LITERAL">RPL</tt> (requested privilege level - stored in
        the bottom two bits of the selector) field of the
        destination (first) operand to ensure that it is no less
        (i.e. no more privileged than) the <tt class=
        "LITERAL">RPL</tt> field of the source operand. The zero
        flag is set if and only if a change had to be made.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-BOUND">B.4.6 <tt class=
        "LITERAL">BOUND</tt>: Check Array Index against
        Bounds</a></h2>
<pre class="SCREEN">
    BOUND reg16,mem               ; o16 62 /r            [186]
    BOUND reg32,mem               ; o32 62 /r            [386]
</pre>

        <p><tt class="LITERAL">BOUND</tt> expects its second
        operand to point to an area of memory containing two signed
        values of the same size as its first operand (i.e. two
        words for the 16-bit form; two doublewords for the 32-bit
        form). It performs two signed comparisons: if the value in
        the register passed as its first operand is less than the
        first of the in-memory values, or is greater than or equal
        to the second, it throws a <tt class="LITERAL">BR</tt>
        exception. Otherwise, it does nothing.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-BSF">B.4.7 <tt class=
        "LITERAL">BSF</tt>, <tt class="LITERAL">BSR</tt>: Bit
        Scan</a></h2>
<pre class="SCREEN">
    BSF reg16,r/m16               ; o16 0F BC /r         [386]
    BSF reg32,r/m32               ; o32 0F BC /r         [386]
    
    BSR reg16,r/m16               ; o16 0F BD /r         [386]
    BSR reg32,r/m32               ; o32 0F BD /r         [386]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">BSF</tt> searches for the least
            significant set bit in its source (second) operand, and
            if it finds one, stores the index in its destination
            (first) operand. If no set bit is found, the contents
            of the destination operand are undefined. If the source
            operand is zero, the zero flag is set.</p>
          </li>

          <li>
            <p><tt class="LITERAL">BSR</tt> performs the same
            function, but searches from the top instead, so it
            finds the most significant set bit.</p>
          </li>
        </ul>

        <p>Bit indices are from 0 (least significant) to 15 or 31
        (most significant). The destination operand can only be a
        register. The source operand can be a register or a memory
        location.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-BSWAP">B.4.8 <tt class=
        "LITERAL">BSWAP</tt>: Byte Swap</a></h2>
<pre class="SCREEN">
    BSWAP reg32                   ; o32 0F C8+r          [486]
</pre>

        <p><tt class="LITERAL">BSWAP</tt> swaps the order of the
        four bytes of a 32-bit register: bits 0-7 exchange places
        with bits 24-31, and bits 8-15 swap with bits 16-23. There
        is no explicit 16-bit equivalent: to byte-swap <tt class=
        "REGISTER">AX</tt>, <tt class="REGISTER">BX</tt>, <tt
        class="REGISTER">CX</tt> or <tt class="REGISTER">DX</tt>,
        <tt class="LITERAL">XCHG</tt> can be used (<a href=
        "inst-ref-general.html#INST-REF-XCHG">Section B.4.151</a>).
        When <tt class="LITERAL">BSWAP</tt> is used with a 16-bit
        register, the result is undefined.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-BT">B.4.9 <tt class=
        "LITERAL">BT</tt>, <tt class="LITERAL">BTC</tt>, <tt class=
        "LITERAL">BTR</tt>, <tt class="LITERAL">BTS</tt>: Bit
        Test</a></h2>
<pre class="SCREEN">
    BT r/m16,reg16                ; o16 0F A3 /r         [386]
    BT r/m32,reg32                ; o32 0F A3 /r         [386]
    BT r/m16,imm8                 ; o16 0F BA /4 ib      [386]
    BT r/m32,imm8                 ; o32 0F BA /4 ib      [386]
    
    BTC r/m16,reg16               ; o16 0F BB /r         [386]
    BTC r/m32,reg32               ; o32 0F BB /r         [386]
    BTC r/m16,imm8                ; o16 0F BA /7 ib      [386]
    BTC r/m32,imm8                ; o32 0F BA /7 ib      [386]
    
    BTR r/m16,reg16               ; o16 0F B3 /r         [386]
    BTR r/m32,reg32               ; o32 0F B3 /r         [386]
    BTR r/m16,imm8                ; o16 0F BA /6 ib      [386]
    BTR r/m32,imm8                ; o32 0F BA /6 ib      [386]
    
    BTS r/m16,reg16               ; o16 0F AB /r         [386]
    BTS r/m32,reg32               ; o32 0F AB /r         [386]
    BTS r/m16,imm                 ; o16 0F BA /5 ib      [386]
    BTS r/m32,imm                 ; o32 0F BA /5 ib      [386]
</pre>

        <p>These instructions all test one bit of their first
        operand, whose index is given by the second operand, and
        store the value of that bit into the carry flag. Bit
        indices are from 0 (least significant) to 15 or 31 (most
        significant).</p>

        <p>In addition to storing the original value of the bit
        into the carry flag, <tt class="LITERAL">BTR</tt> also
        resets (clears) the bit in the operand itself. <tt class=
        "LITERAL">BTS</tt> sets the bit, and <tt class=
        "LITERAL">BTC</tt> complements the bit. <tt class=
        "LITERAL">BT</tt> does not modify its operands.</p>

        <p>The destination can be a register or a memory location.
        The source can be a register or an immediate value.</p>

        <p>If the destination operand is a register, the bit offset
        should be in the range 0-15 (for 16-bit operands) or 0-31
        (for 32-bit operands). An immediate value outside these
        ranges will be taken modulo 16/32 by the processor.</p>

        <p>If the destination operand is a memory location, then an
        immediate bit offset follows the same rules as for a
        register. If the bit offset is in a register, then it can
        be anything within the signed range of the register used
        (ie, for a 32-bit operand, it can be (-2^31) to (2^31 -
        1).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CALL">B.4.10 <tt class=
        "LITERAL">CALL</tt>: Call Subroutine</a></h2>
<pre class="SCREEN">
    CALL imm                      ; E8 rw/rd             [8086]
    CALL imm:imm16                ; o16 9A iw iw         [8086]
    CALL imm:imm32                ; o32 9A id iw         [386]
    CALL FAR mem16                ; o16 FF /3            [8086]
    CALL FAR mem32                ; o32 FF /3            [386]
    CALL r/m16                    ; o16 FF /2            [8086]
    CALL r/m32                    ; o32 FF /2            [386]
</pre>

        <p><tt class="LITERAL">CALL</tt> calls a subroutine, by
        means of pushing the current instruction pointer (<tt
        class="REGISTER">IP</tt>) and optionally <tt class=
        "REGISTER">CS</tt> as well on the stack, and then jumping
        to a given address.</p>

        <p><tt class="REGISTER">CS</tt> is pushed as well as <tt
        class="REGISTER">IP</tt> if and only if the call is a far
        call, i.e. a destination segment address is specified in
        the instruction. The forms involving two colon-separated
        arguments are far calls; so are the <tt class=
        "LITERAL">CALL FAR mem</tt> forms.</p>

        <p>The immediate near call takes one of two forms (<tt
        class="LITERAL">CALL imm16/imm32</tt>, determined by the
        current segment size limit). For 16-bit operands, you would
        use <tt class="LITERAL">CALL 0x1234</tt>, and for 32-bit
        operands you would use <tt class="LITERAL">CALL
        0x12345678</tt>. The value passed as an operand is a
        relative offset.</p>

        <p>You can choose between the two immediate far call forms
        (<tt class="LITERAL">CALL imm:imm</tt>) by the use of the
        <tt class="LITERAL">WORD</tt> and <tt class=
        "LITERAL">DWORD</tt> keywords: <tt class="LITERAL">CALL
        WORD 0x1234:0x5678</tt>) or <tt class="LITERAL">CALL DWORD
        0x1234:0x56789abc</tt>.</p>

        <p>The <tt class="LITERAL">CALL FAR mem</tt> forms execute
        a far call by loading the destination address out of
        memory. The address loaded consists of 16 or 32 bits of
        offset (depending on the operand size), and 16 bits of
        segment. The operand size may be overridden using <tt
        class="LITERAL">CALL WORD FAR mem</tt> or <tt class=
        "LITERAL">CALL DWORD FAR mem</tt>.</p>

        <p>The <tt class="LITERAL">CALL r/m</tt> forms execute a
        near call (within the same segment), loading the
        destination address out of memory or out of a register. The
        keyword <tt class="LITERAL">NEAR</tt> may be specified, for
        clarity, in these forms, but is not necessary. Again,
        operand size can be overridden using <tt class=
        "LITERAL">CALL WORD mem</tt> or <tt class="LITERAL">CALL
        DWORD mem</tt>.</p>

        <p>As a convenience, NASM does not require you to call a
        far procedure symbol by coding the cumbersome <tt class=
        "LITERAL">CALL SEG routine:routine</tt>, but instead allows
        the easier synonym <tt class="LITERAL">CALL FAR
        routine</tt>.</p>

        <p>The <tt class="LITERAL">CALL r/m</tt> forms given above
        are near calls; NASM will accept the <tt class=
        "LITERAL">NEAR</tt> keyword (e.g. <tt class="LITERAL">CALL
        NEAR [address]</tt>), even though it is not strictly
        necessary.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CBW">B.4.11 <tt class=
        "LITERAL">CBW</tt>, <tt class="LITERAL">CWD</tt>, <tt
        class="LITERAL">CDQ</tt>, <tt class="LITERAL">CWDE</tt>:
        Sign Extensions</a></h2>
<pre class="SCREEN">
    CBW                           ; o16 98               [8086]
    CWDE                          ; o32 98               [386]
    
    CWD                           ; o16 99               [8086]
    CDQ                           ; o32 99               [386]
</pre>

        <p>All these instructions sign-extend a short value into a
        longer one, by replicating the top bit of the original
        value to fill the extended one.</p>

        <p><tt class="LITERAL">CBW</tt> extends <tt class=
        "REGISTER">AL</tt> into <tt class="REGISTER">AX</tt> by
        repeating the top bit of <tt class="REGISTER">AL</tt> in
        every bit of <tt class="REGISTER">AH</tt>. <tt class=
        "LITERAL">CWDE</tt> extends <tt class="REGISTER">AX</tt>
        into <tt class="REGISTER">EAX</tt>. <tt class=
        "LITERAL">CWD</tt> extends <tt class="REGISTER">AX</tt>
        into <tt class="LITERAL"><tt class="REGISTER">DX</tt>:<tt
        class="REGISTER">AX</tt></tt> by repeating the top bit of
        <tt class="REGISTER">AX</tt> throughout <tt class=
        "REGISTER">DX</tt>, and <tt class="LITERAL">CDQ</tt>
        extends <tt class="REGISTER">EAX</tt> into <tt class=
        "LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
        "REGISTER">EAX</tt></tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CLC">B.4.12 <tt class=
        "LITERAL">CLC</tt>, <tt class="LITERAL">CLD</tt>, <tt
        class="LITERAL">CLI</tt>, <tt class="LITERAL">CLTS</tt>:
        Clear Flags</a></h2>
<pre class="SCREEN">
    CLC                           ; F8                   [8086]
    CLD                           ; FC                   [8086]
    CLI                           ; FA                   [8086]
    CLTS                          ; 0F 06                [286,PRIV]
</pre>

        <p>These instructions clear various flags. <tt class=
        "LITERAL">CLC</tt> clears the carry flag; <tt class=
        "LITERAL">CLD</tt> clears the direction flag; <tt class=
        "LITERAL">CLI</tt> clears the interrupt flag (thus
        disabling interrupts); and <tt class="LITERAL">CLTS</tt>
        clears the task-switched (<tt class="REGISTER">TS</tt>)
        flag in <tt class="REGISTER">CR0</tt>.</p>

        <p>To set the carry, direction, or interrupt flags, use the
        <tt class="LITERAL">STC</tt>, <tt class="LITERAL">STD</tt>
        and <tt class="LITERAL">STI</tt> instructions (<a href=
        "inst-ref-general.html#INST-REF-STC">Section B.4.137</a>).
        To invert the carry flag, use <tt class="LITERAL">CMC</tt>
        (<a href="inst-ref-general.html#INST-REF-CMC">Section
        B.4.14</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CLFLUSH">B.4.13 <tt
        class="LITERAL">CLFLUSH</tt>: Flush Cache Line</a></h2>
<pre class="SCREEN">
    CLFLUSH mem                   ; 0F AE /7        [WILLAMETTE,SSE2]
</pre>

        <p><tt class="LITERAL">CLFLUSH</tt> invalidates the cache
        line that contains the linear address specified by the
        source operand from all levels of the processor cache
        hierarchy (data and instruction). If, at any level of the
        cache hierarchy, the line is inconsistent with memory
        (dirty) it is written to memory before invalidation. The
        source operand points to a byte-sized memory location.</p>

        <p>Although <tt class="LITERAL">CLFLUSH</tt>s flagged <tt
        class="LITERAL">SSE2</tt>nd above, it may not be present on
        all processors which have <tt class="LITERAL">SSE2</tt>
        support, and it may be supported on other processors; the
        <tt class="LITERAL">CPUID</tt> instruction (<a href=
        "inst-ref-general.html#INST-REF-CPUID">Section B.4.20</a>)
        will return a bit which indicates support for the <tt
        class="LITERAL">CLFLUSH</tt> instruction.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMC">B.4.14 <tt class=
        "LITERAL">CMC</tt>: Complement Carry Flag</a></h2>
<pre class="SCREEN">
    CMC                           ; F5                   [8086]
</pre>

        <p><tt class="LITERAL">CMC</tt> changes the value of the
        carry flag: if it was 0, it sets it to 1, and vice
        versa.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMOVCC">B.4.15 <tt
        class="LITERAL">CMOVcc</tt>: Conditional Move</a></h2>
<pre class="SCREEN">
    CMOVcc reg16,r/m16            ; o16 0F 40+cc /r      [P6]
    CMOVcc reg32,r/m32            ; o32 0F 40+cc /r      [P6]
</pre>

        <p><tt class="LITERAL">CMOV</tt> moves its source (second)
        operand into its destination (first) operand if the given
        condition code is satisfied; otherwise it does nothing.</p>

        <p>For a list of condition codes, see <a href=
        "inst-ref-opcode-desc.html#INST-REF-OPCODE-DESC-COND-CODES">
        Section B.2.2</a>.</p>

        <p>Although the <tt class="LITERAL">CMOV</tt> instructions
        are flagged <tt class="LITERAL">P6</tt> and above, they may
        not be supported by all Pentium Pro processors; the <tt
        class="LITERAL">CPUID</tt> instruction (<a href=
        "inst-ref-general.html#INST-REF-CPUID">Section B.4.20</a>)
        will return a bit which indicates whether conditional moves
        are supported.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMP">B.4.16 <tt class=
        "LITERAL">CMP</tt>: Compare Integers</a></h2>
<pre class="SCREEN">
    CMP r/m8,reg8                 ; 38 /r                [8086]
    CMP r/m16,reg16               ; o16 39 /r            [8086]
    CMP r/m32,reg32               ; o32 39 /r            [386]
    
    CMP reg8,r/m8                 ; 3A /r                [8086]
    CMP reg16,r/m16               ; o16 3B /r            [8086]
    CMP reg32,r/m32               ; o32 3B /r            [386]
    
    CMP r/m8,imm8                 ; 80 /0 ib             [8086]
    CMP r/m16,imm16               ; o16 81 /0 iw         [8086]
    CMP r/m32,imm32               ; o32 81 /0 id         [386]
    
    CMP r/m16,imm8                ; o16 83 /0 ib         [8086]
    CMP r/m32,imm8                ; o32 83 /0 ib         [386]
    
    CMP AL,imm8                   ; 3C ib                [8086]
    CMP AX,imm16                  ; o16 3D iw            [8086]
    CMP EAX,imm32                 ; o32 3D id            [386]
</pre>

        <p><tt class="LITERAL">CMP</tt> performs a `mental'
        subtraction of its second operand from its first operand,
        and affects the flags as if the subtraction had taken
        place, but does not store the result of the subtraction
        anywhere.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>The destination operand can be a register or a memory
        location. The source can be a register, memory location, or
        an immediate value of the same size as the destination.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMPSB">B.4.17 <tt
        class="LITERAL">CMPSB</tt>, <tt class="LITERAL">CMPSW</tt>,
        <tt class="LITERAL">CMPSD</tt>: Compare Strings</a></h2>
<pre class="SCREEN">
    CMPSB                         ; A6                   [8086]
    CMPSW                         ; o16 A7               [8086]
    CMPSD                         ; o32 A7               [386]
</pre>

        <p><tt class="LITERAL">CMPSB</tt> compares the byte at <tt
        class="LITERAL">[<tt class="REGISTER">DS</tt>:<tt class=
        "REGISTER">SI</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">DS</tt>:<tt class="REGISTER">ESI</tt>]</tt> with
        the byte at <tt class="LITERAL">[<tt class=
        "REGISTER">ES</tt>:<tt class="REGISTER">DI</tt>]</tt> or
        <tt class="LITERAL">[<tt class="REGISTER">ES</tt>:<tt
        class="REGISTER">EDI</tt>]</tt>, and sets the flags
        accordingly. It then increments or decrements (depending on
        the direction flag: increments if the flag is clear,
        decrements if it is set) <tt class="REGISTER">SI</tt> and
        <tt class="REGISTER">DI</tt> (or <tt class=
        "REGISTER">ESI</tt> and <tt class="REGISTER">EDI</tt>).</p>

        <p>The registers used are <tt class="REGISTER">SI</tt> and
        <tt class="REGISTER">DI</tt> if the address size is 16
        bits, and <tt class="REGISTER">ESI</tt> and <tt class=
        "REGISTER">EDI</tt> if it is 32 bits. If you need to use an
        address size not equal to the current <tt class=
        "LITERAL">BITS</tt> setting, you can use an explicit <tt
        class="LITERAL">a16</tt> or <tt class="LITERAL">a32</tt>
        prefix.</p>

        <p>The segment register used to load from <tt class=
        "LITERAL">[<tt class="REGISTER">SI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">ESI</tt>]</tt> can be
        overridden by using a segment register name as a prefix
        (for example, <tt class="LITERAL"><tt class=
        "REGISTER">ES</tt> CMPSB</tt>). The use of <tt class=
        "REGISTER">ES</tt> for the load from <tt class=
        "LITERAL">[<tt class="REGISTER">DI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">EDI</tt>]</tt> cannot be
        overridden.</p>

        <p><tt class="LITERAL">CMPSW</tt> and <tt class=
        "LITERAL">CMPSD</tt> work in the same way, but they compare
        a word or a doubleword instead of a byte, and increment or
        decrement the addressing registers by 2 or 4 instead of
        1.</p>

        <p>The <tt class="LITERAL">REPE</tt> and <tt class=
        "LITERAL">REPNE</tt> prefixes (equivalently, <tt class=
        "LITERAL">REPZ</tt> and <tt class="LITERAL">REPNZ</tt>) may
        be used to repeat the instruction up to <tt class=
        "REGISTER">CX</tt> (or <tt class="REGISTER">ECX</tt> -
        again, the address size chooses which) times until the
        first unequal or equal byte is found.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMPXCHG">B.4.18 <tt
        class="LITERAL">CMPXCHG</tt>: Compare and Exchange</a></h2>
<pre class="SCREEN">
    CMPXCHG r/m8,reg8             ; 0F B0 /r             [PENT]
    CMPXCHG r/m16,reg16           ; o16 0F B1 /r         [PENT]
    CMPXCHG r/m32,reg32           ; o32 0F B1 /r         [PENT]
</pre>

        <p><tt class="LITERAL">CMPXCHG</tt> compares its
        destination (first) operand to the value in <tt class=
        "REGISTER">AL</tt>, <tt class="REGISTER">AX</tt> or <tt
        class="REGISTER">EAX</tt> (depending on the operand size of
        the instruction). If they are equal, it copies its source
        (second) operand into the destination and sets the zero
        flag. Otherwise, it clears the zero flag and copies the
        destination register to <tt class="REGISTER">AL</tt>, <tt
        class="REGISTER">AX</tt>, or <tt class=
        "REGISTER">EAX</tt>.</p>

        <p>The destination can be either a register or a memory
        location. The source is a register.</p>

        <p><tt class="LITERAL">CMPXCHG</tt> is intended to be used
        for atomic operations in multitasking or multiprocessor
        environments. To safely update a value in shared memory,
        for example, you might load the value into <tt class=
        "REGISTER">EAX</tt>, load the updated value into <tt class=
        "REGISTER">EBX</tt>, and then execute the instruction <tt
        class="LITERAL">LOCK CMPXCHG [value],<tt class=
        "REGISTER">EBX</tt></tt>. If <tt class="LITERAL">value</tt>
        has not changed since being loaded, it is updated with your
        desired new value, and the zero flag is set to let you know
        it has worked. (The <tt class="LITERAL">LOCK</tt> prefix
        prevents another processor doing anything in the middle of
        this operation: it guarantees atomicity.) However, if
        another processor has modified the value in between your
        load and your attempted store, the store does not happen,
        and you are notified of the failure by a cleared zero flag,
        so you can go round and try again.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CMPXCHG8B">B.4.19 <tt
        class="LITERAL">CMPXCHG8B</tt>: Compare and Exchange Eight
        Bytes</a></h2>
<pre class="SCREEN">
    CMPXCHG8B mem                 ; 0F C7 /1             [PENT]
</pre>

        <p>This is a larger and more unwieldy version of <tt class=
        "LITERAL">CMPXCHG</tt>: it compares the 64-bit (eight-byte)
        value stored at <tt class="LITERAL">[mem]</tt> with the
        value in <tt class="LITERAL"><tt class=
        "REGISTER">EDX</tt>:<tt class="REGISTER">EAX</tt></tt>. If
        they are equal, it sets the zero flag and stores <tt class=
        "LITERAL"><tt class="REGISTER">ECX</tt>:<tt class=
        "REGISTER">EBX</tt></tt> into the memory area. If they are
        unequal, it clears the zero flag and leaves the memory area
        untouched.</p>

        <p><tt class="LITERAL">CMPXCHG8B</tt> can be used with the
        <tt class="LITERAL">LOCK</tt> prefix, to allow atomic
        execution. This is useful in multi-processor and
        multi-tasking environments.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-CPUID">B.4.20 <tt
        class="LITERAL">CPUID</tt>: Get CPU Identification
        Code</a></h2>
<pre class="SCREEN">
    CPUID                         ; 0F A2                [PENT]
</pre>

        <p><tt class="LITERAL">CPUID</tt> returns various
        information about the processor it is being executed on. It
        fills the four registers <tt class="REGISTER">EAX</tt>, <tt
        class="REGISTER">EBX</tt>, <tt class="REGISTER">ECX</tt>
        and <tt class="REGISTER">EDX</tt> with information, which
        varies depending on the input contents of <tt class=
        "REGISTER">EAX</tt>.</p>

        <p><tt class="LITERAL">CPUID</tt> also acts as a barrier to
        serialise instruction execution: executing the <tt class=
        "LITERAL">CPUID</tt> instruction guarantees that all the
        effects (memory modification, flag modification, register
        modification) of previous instructions have been completed
        before the next instruction gets fetched.</p>

        <p>The information returned is as follows:</p>

        <ul>
          <li>
            <p>If <tt class="REGISTER">EAX</tt> is zero on input,
            <tt class="REGISTER">EAX</tt> on output holds the
            maximum acceptable input value of <tt class=
            "REGISTER">EAX</tt>, and <tt class="LITERAL"><tt class=
            "REGISTER">EBX</tt>:<tt class="REGISTER">EDX</tt>:<tt
            class="REGISTER">ECX</tt></tt> contain the string <tt
            class="LITERAL">"GenuineIntel"</tt> (or not, if you
            have a clone processor). That is to say, <tt class=
            "REGISTER">EBX</tt> contains <tt class=
            "LITERAL">"Genu"</tt> (in NASM's own sense of character
            constants, described in <a href=
            "nasm-const.html#NASM-CONST-CHAR">Section 5.4.2</a>),
            <tt class="REGISTER">EDX</tt> contains <tt class=
            "LITERAL">"ineI"</tt> and <tt class="REGISTER">ECX</tt>
            contains <tt class="LITERAL">"ntel"</tt>.</p>
          </li>

          <li>
            <p>If <tt class="REGISTER">EAX</tt> is one on input,
            <tt class="REGISTER">EAX</tt> on output contains
            version information about the processor, and <tt class=
            "REGISTER">EDX</tt> contains a set of feature flags,
            showing the presence and absence of various features.
            For example, bit 8 is set if the <tt class=
            "LITERAL">CMPXCHG8B</tt> instruction (<a href=
            "inst-ref-general.html#INST-REF-CMPXCHG8B">Section
            B.4.19</a>) is supported, bit 15 is set if the
            conditional move instructions (<a href=
            "inst-ref-general.html#INST-REF-CMOVCC">Section
            B.4.15</a> and <a href=
            "inst-ref-general.html#INST-REF-FCMOVB">Section
            B.4.32</a>) are supported, and bit 23 is set if <tt
            class="REGISTER">MMX</tt> instructions are
            supported.</p>
          </li>

          <li>
            <p>If <tt class="REGISTER">EAX</tt> is two on input,
            <tt class="REGISTER">EAX</tt>, <tt class=
            "REGISTER">EBX</tt>, <tt class="REGISTER">ECX</tt> and
            <tt class="REGISTER">EDX</tt> all contain information
            about caches and TLBs (Translation Lookahead
            Buffers).</p>
          </li>
        </ul>

        <p>For more information on the data returned from <tt
        class="LITERAL">CPUID</tt>, see the documentation from
        Intel and other processor manufacturers.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-DAA">B.4.21 <tt class=
        "LITERAL">DAA</tt>, <tt class="LITERAL">DAS</tt>: Decimal
        Adjustments</a></h2>
<pre class="SCREEN">
    DAA                           ; 27                   [8086]
    DAS                           ; 2F                   [8086]
</pre>

        <p>These instructions are used in conjunction with the add
        and subtract instructions to perform binary-coded decimal
        arithmetic in <span class="emphasis"><i class=
        "EMPHASIS">packed</i></span> (one BCD digit per nibble)
        form. For the unpacked equivalents, see <a href=
        "inst-ref-general.html#INST-REF-AAA">Section B.4.1</a>.</p>

        <p><tt class="LITERAL">DAA</tt> should be used after a
        one-byte <tt class="LITERAL">ADD</tt> instruction whose
        destination was the <tt class="REGISTER">AL</tt> register:
        by means of examining the value in the <tt class=
        "REGISTER">AL</tt> and also the auxiliary carry flag <tt
        class="REGISTER">AF</tt>, it determines whether either
        digit of the addition has overflowed, and adjusts it (and
        sets the carry and auxiliary-carry flags) if so. You can
        add long BCD strings together by doing <tt class=
        "LITERAL">ADD</tt>/<tt class="LITERAL">DAA</tt> on the low
        two digits, then doing <tt class="LITERAL">ADC</tt>/<tt
        class="LITERAL">DAA</tt> on each subsequent pair of
        digits.</p>

        <p><tt class="LITERAL">DAS</tt> works similarly to <tt
        class="LITERAL">DAA</tt>, but is for use after <tt class=
        "LITERAL">SUB</tt> instructions rather than <tt class=
        "LITERAL">ADD</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-DEC">B.4.22 <tt class=
        "LITERAL">DEC</tt>: Decrement Integer</a></h2>
<pre class="SCREEN">
    DEC reg16                     ; o16 48+r             [8086]
    DEC reg32                     ; o32 48+r             [386]
    DEC r/m8                      ; FE /1                [8086]
    DEC r/m16                     ; o16 FF /1            [8086]
    DEC r/m32                     ; o32 FF /1            [386]
</pre>

        <p><tt class="LITERAL">DEC</tt> subtracts 1 from its
        operand. It does <span class="emphasis"><i class=
        "EMPHASIS">not</i></span> affect the carry flag: to affect
        the carry flag, use <tt class="LITERAL">SUB
        something,1</tt> (see <a href=
        "inst-ref-general.html#INST-REF-SUB">Section B.4.140</a>).
        See also <tt class="LITERAL">INC</tt> (<a href=
        "inst-ref-general.html#INST-REF-INC">Section
        B.4.78</a>).</p>

        <p>This instruction can be used with a <tt class=
        "LITERAL">LOCK</tt> prefix to allow atomic execution.</p>

        <p>See also <tt class="LITERAL">INC</tt> (<a href=
        "inst-ref-general.html#INST-REF-INC">Section
        B.4.78</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-DIV">B.4.23 <tt class=
        "LITERAL">DIV</tt>: Unsigned Integer Divide</a></h2>
<pre class="SCREEN">
    DIV r/m8                      ; F6 /6                [8086]
    DIV r/m16                     ; o16 F7 /6            [8086]
    DIV r/m32                     ; o32 F7 /6            [386]
</pre>

        <p><tt class="LITERAL">DIV</tt> performs unsigned integer
        division. The explicit operand provided is the divisor; the
        dividend and destination operands are implicit, in the
        following way:</p>

        <ul>
          <li>
            <p>For <tt class="LITERAL">DIV r/m8</tt>, <tt class=
            "REGISTER">AX</tt> is divided by the given operand; the
            quotient is stored in <tt class="REGISTER">AL</tt> and
            the remainder in <tt class="REGISTER">AH</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">DIV r/m16</tt>, <tt class=
            "LITERAL"><tt class="REGISTER">DX</tt>:<tt class=
            "REGISTER">AX</tt></tt> is divided by the given
            operand; the quotient is stored in <tt class=
            "REGISTER">AX</tt> and the remainder in <tt class=
            "REGISTER">DX</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">DIV r/m32</tt>, <tt class=
            "LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
            "REGISTER">EAX</tt></tt> is divided by the given
            operand; the quotient is stored in <tt class=
            "REGISTER">EAX</tt> and the remainder in <tt class=
            "REGISTER">EDX</tt>.</p>
          </li>
        </ul>

        <p>Signed integer division is performed by the <tt class=
        "LITERAL">IDIV</tt> instruction: see <a href=
        "inst-ref-general.html#INST-REF-IDIV">Section
        B.4.75</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-EMMS">B.4.24 <tt class=
        "LITERAL">EMMS</tt>: Empty MMX State</a></h2>
<pre class="SCREEN">
    EMMS                          ; 0F 77                [PENT,MMX]
</pre>

        <p><tt class="LITERAL">EMMS</tt> sets the FPU tag word
        (marking which floating-point registers are available) to
        all ones, meaning all registers are available for the FPU
        to use. It should be used after executing <tt class=
        "REGISTER">MMX</tt> instructions and before executing any
        subsequent floating-point operations.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-ENTER">B.4.25 <tt
        class="LITERAL">ENTER</tt>: Create Stack Frame</a></h2>
<pre class="SCREEN">
    ENTER imm,imm                 ; C8 iw ib             [186]
</pre>

        <p><tt class="LITERAL">ENTER</tt> constructs a stack frame
        for a high-level language procedure call. The first operand
        (the <tt class="LITERAL">iw</tt> in the opcode definition
        above refers to the first operand) gives the amount of
        stack space to allocate for local variables; the second
        (the <tt class="LITERAL">ib</tt> above) gives the nesting
        level of the procedure (for languages like Pascal, with
        nested procedures).</p>

        <p>The function of <tt class="LITERAL">ENTER</tt>, with a
        nesting level of zero, is equivalent to</p>
<pre class="PROGRAMLISTING">
        PUSH    EBP             ; or PUSH BP          in 16 bits
        MOV     EBP, ESP        ; or MOV BP, SP       in 16 bits
        SUB     ESP, operand1   ; or SUB SP, operand1 in 16 bits
</pre>

        <p>This creates a stack frame with the procedure parameters
        accessible upwards from <tt class="REGISTER">EBP</tt>, and
        local variables accessible downwards from <tt class=
        "REGISTER">EBP</tt>.</p>

        <p>With a nesting level of one, the stack frame created is
        4 (or 2) bytes bigger, and the value of the final frame
        pointer <tt class="REGISTER">EBP</tt> is accessible in
        memory at <tt class="LITERAL">[<tt class=
        "REGISTER">EBP</tt>-4]</tt>.</p>

        <p>This allows <tt class="LITERAL">ENTER</tt>, when called
        with a nesting level of two, to look at the stack frame
        described by the <span class="emphasis"><i class=
        "EMPHASIS">previous</i></span> value of <tt class=
        "REGISTER">EBP</tt>, find the frame pointer at offset -4
        from that, and push it along with its new frame pointer, so
        that when a level-two procedure is called from within a
        level-one procedure, <tt class="LITERAL">[<tt class=
        "REGISTER">EBP</tt>-4]</tt> holds the frame pointer of the
        most recent level-one procedure call and <tt class=
        "LITERAL">[<tt class="REGISTER">EBP</tt>-8]</tt> holds that
        of the most recent level-two call. And so on, for nesting
        levels up to 31.</p>

        <p>Stack frames created by <tt class="LITERAL">ENTER</tt>
        can be destroyed by the <tt class="LITERAL">LEAVE</tt>
        instruction: see <a href=
        "inst-ref-general.html#INST-REF-LEAVE">Section
        B.4.93</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-F2XM1">B.4.26 <tt
        class="LITERAL">F2XM1</tt>: Calculate 2**X-1</a></h2>
<pre class="SCREEN">
    F2XM1                         ; D9 F0                [8086,FPU]
</pre>

        <p><tt class="LITERAL">F2XM1</tt> raises 2 to the power of
        <tt class="REGISTER">ST0</tt>, subtracts one, and stores
        the result back into <tt class="REGISTER">ST0</tt>. The
        initial contents of <tt class="REGISTER">ST0</tt> must be a
        number in the range -1.0 to +1.0.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FABS">B.4.27 <tt class=
        "LITERAL">FABS</tt>: Floating-Point Absolute Value</a></h2>
<pre class="SCREEN">
    FABS                          ; D9 E1                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FABS</tt> computes the absolute
        value of <tt class="REGISTER">ST0</tt>, by clearing the
        sign bit, and stores the result back into <tt class=
        "REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FADD">B.4.28 <tt class=
        "LITERAL">FADD</tt>, <tt class="LITERAL">FADDP</tt>:
        Floating-Point Addition</a></h2>
<pre class="SCREEN">
    FADD mem32                    ; D8 /0                [8086,FPU]
    FADD mem64                    ; DC /0                [8086,FPU]
    
    FADD fpureg                   ; D8 C0+r              [8086,FPU]
    FADD ST0,fpureg               ; D8 C0+r              [8086,FPU]
    
    FADD TO fpureg                ; DC C0+r              [8086,FPU]
    FADD fpureg,ST0               ; DC C0+r              [8086,FPU]
    
    FADDP fpureg                  ; DE C0+r              [8086,FPU]
    FADDP fpureg,ST0              ; DE C0+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FADD</tt>, given one operand, adds
        the operand to <tt class="REGISTER">ST0</tt> and stores the
        result back in <tt class="REGISTER">ST0</tt>. If the
        operand has the <tt class="LITERAL">TO</tt> modifier, the
        result is stored in the register given rather than in <tt
        class="REGISTER">ST0</tt>.</p>

        <p><tt class="LITERAL">FADDP</tt> performs the same
        function as <tt class="LITERAL">FADD TO</tt>, but pops the
        register stack after storing the result.</p>

        <p>The given two-operand forms are synonyms for the
        one-operand forms.</p>

        <p>To add an integer value to <tt class=
        "REGISTER">ST0</tt>, use the <tt class="LITERAL">FIADD</tt>
        instruction (<a href=
        "inst-ref-general.html#INST-REF-FIADD">Section
        B.4.39</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FBLD">B.4.29 <tt class=
        "LITERAL">FBLD</tt>, <tt class="LITERAL">FBSTP</tt>: BCD
        Floating-Point Load and Store</a></h2>
<pre class="SCREEN">
    FBLD mem80                    ; DF /4                [8086,FPU]
    FBSTP mem80                   ; DF /6                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FBLD</tt> loads an 80-bit (ten-byte)
        packed binary-coded decimal number from the given memory
        address, converts it to a real, and pushes it on the
        register stack. <tt class="LITERAL">FBSTP</tt> stores the
        value of <tt class="REGISTER">ST0</tt>, in packed BCD, at
        the given address and then pops the register stack.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FCHS">B.4.30 <tt class=
        "LITERAL">FCHS</tt>: Floating-Point Change Sign</a></h2>
<pre class="SCREEN">
    FCHS                          ; D9 E0                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FCHS</tt> negates the number in <tt
        class="REGISTER">ST0</tt> by inverting the sign bit:
        negative numbers become positive, and vice versa.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FCLEX">B.4.31 <tt
        class="LITERAL">FCLEX</tt>, <tt class=
        "LITERAL">FNCLEX</tt>: Clear Floating-Point
        Exceptions</a></h2>
<pre class="SCREEN">
    FCLEX                         ; 9B DB E2             [8086,FPU]
    FNCLEX                        ; DB E2                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FCLEX</tt> clears any floating-point
        exceptions which may be pending. <tt class=
        "LITERAL">FNCLEX</tt> does the same thing but doesn't wait
        for previous floating-point operations (including the <span
        class="emphasis"><i class="EMPHASIS">handling</i></span> of
        pending exceptions) to finish first.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FCMOVB">B.4.32 <tt
        class="LITERAL">FCMOVcc</tt>: Floating-Point Conditional
        Move</a></h2>
<pre class="SCREEN">
    FCMOVB fpureg                 ; DA C0+r              [P6,FPU]
    FCMOVB ST0,fpureg             ; DA C0+r              [P6,FPU]
    
    FCMOVE fpureg                 ; DA C8+r              [P6,FPU]
    FCMOVE ST0,fpureg             ; DA C8+r              [P6,FPU]
    
    FCMOVBE fpureg                ; DA D0+r              [P6,FPU]
    FCMOVBE ST0,fpureg            ; DA D0+r              [P6,FPU]
    
    FCMOVU fpureg                 ; DA D8+r              [P6,FPU]
    FCMOVU ST0,fpureg             ; DA D8+r              [P6,FPU]
    
    FCMOVNB fpureg                ; DB C0+r              [P6,FPU]
    FCMOVNB ST0,fpureg            ; DB C0+r              [P6,FPU]
    
    FCMOVNE fpureg                ; DB C8+r              [P6,FPU]
    FCMOVNE ST0,fpureg            ; DB C8+r              [P6,FPU]
    
    FCMOVNBE fpureg               ; DB D0+r              [P6,FPU]
    FCMOVNBE ST0,fpureg           ; DB D0+r              [P6,FPU]
    
    FCMOVNU fpureg                ; DB D8+r              [P6,FPU]
    FCMOVNU ST0,fpureg            ; DB D8+r              [P6,FPU]
</pre>

        <p>The <tt class="LITERAL">FCMOV</tt> instructions perform
        conditional move operations: each of them moves the
        contents of the given register into <tt class=
        "REGISTER">ST0</tt> if its condition is satisfied, and does
        nothing if not.</p>

        <p>The conditions are not the same as the standard
        condition codes used with conditional jump instructions.
        The conditions <tt class="LITERAL">B</tt>, <tt class=
        "LITERAL">BE</tt>, <tt class="LITERAL">NB</tt>, <tt class=
        "LITERAL">NBE</tt>, <tt class="LITERAL">E</tt> and <tt
        class="LITERAL">NE</tt> are exactly as normal, but none of
        the other standard ones are supported. Instead, the
        condition <tt class="LITERAL">U</tt> and its counterpart
        <tt class="LITERAL">NU</tt> are provided; the <tt class=
        "LITERAL">U</tt> condition is satisfied if the last two
        floating-point numbers compared were <span class=
        "emphasis"><i class="EMPHASIS">unordered</i></span>, i.e.
        they were not equal but neither one could be said to be
        greater than the other, for example if they were NaNs. (The
        flag state which signals this is the setting of the parity
        flag: so the <tt class="LITERAL">U</tt> condition is
        notionally equivalent to <tt class="LITERAL">PE</tt>, and
        <tt class="LITERAL">NU</tt> is equivalent to <tt class=
        "LITERAL">PO</tt>.)</p>

        <p>The <tt class="LITERAL">FCMOV</tt> conditions test the
        main processor's status flags, not the FPU status flags, so
        using <tt class="LITERAL">FCMOV</tt> directly after <tt
        class="LITERAL">FCOM</tt> will not work. Instead, you
        should either use <tt class="LITERAL">FCOMI</tt> which
        writes directly to the main CPU flags word, or use <tt
        class="LITERAL">FSTSW</tt> to extract the FPU flags.</p>

        <p>Although the <tt class="LITERAL">FCMOV</tt> instructions
        are flagged <tt class="LITERAL">P6</tt> above, they may not
        be supported by all Pentium Pro processors; the <tt class=
        "LITERAL">CPUID</tt> instruction (<a href=
        "inst-ref-general.html#INST-REF-CPUID">Section B.4.20</a>)
        will return a bit which indicates whether conditional moves
        are supported.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FCOM">B.4.33 <tt class=
        "LITERAL">FCOM</tt>, <tt class="LITERAL">FCOMP</tt>, <tt
        class="LITERAL">FCOMPP</tt>, <tt class=
        "LITERAL">FCOMI</tt>, <tt class="LITERAL">FCOMIP</tt>:
        Floating-Point Compare</a></h2>
<pre class="SCREEN">
    FCOM mem32                    ; D8 /2                [8086,FPU]
    FCOM mem64                    ; DC /2                [8086,FPU]
    FCOM fpureg                   ; D8 D0+r              [8086,FPU]
    FCOM ST0,fpureg               ; D8 D0+r              [8086,FPU]
    
    FCOMP mem32                   ; D8 /3                [8086,FPU]
    FCOMP mem64                   ; DC /3                [8086,FPU]
    FCOMP fpureg                  ; D8 D8+r              [8086,FPU]
    FCOMP ST0,fpureg              ; D8 D8+r              [8086,FPU]
    
    FCOMPP                        ; DE D9                [8086,FPU]
    
    FCOMI fpureg                  ; DB F0+r              [P6,FPU]
    FCOMI ST0,fpureg              ; DB F0+r              [P6,FPU]
    
    FCOMIP fpureg                 ; DF F0+r              [P6,FPU]
    FCOMIP ST0,fpureg             ; DF F0+r              [P6,FPU]
</pre>

        <p><tt class="LITERAL">FCOM</tt> compares <tt class=
        "REGISTER">ST0</tt> with the given operand, and sets the
        FPU flags accordingly. <tt class="REGISTER">ST0</tt> is
        treated as the left-hand side of the comparison, so that
        the carry flag is set (for a <span class=
        "QUOTE">"less-than"</span> result) if <tt class=
        "REGISTER">ST0</tt> is less than the given operand.</p>

        <p><tt class="LITERAL">FCOMP</tt> does the same as <tt
        class="LITERAL">FCOM</tt>, but pops the register stack
        afterwards. <tt class="LITERAL">FCOMPP</tt> compares <tt
        class="REGISTER">ST0</tt> with <tt class=
        "REGISTER">ST1</tt> and then pops the register stack
        twice.</p>

        <p><tt class="LITERAL">FCOMI</tt> and <tt class=
        "LITERAL">FCOMIP</tt> work like the corresponding forms of
        <tt class="LITERAL">FCOM</tt> and <tt class=
        "LITERAL">FCOMP</tt>, but write their results directly to
        the CPU flags register rather than the FPU status word, so
        they can be immediately followed by conditional jump or
        conditional move instructions.</p>

        <p>The <tt class="LITERAL">FCOM</tt> instructions differ
        from the <tt class="LITERAL">FUCOM</tt> instructions (<a
        href="inst-ref-general.html#INST-REF-FUCOM">Section
        B.4.67</a>) only in the way they handle quiet NaNs: <tt
        class="LITERAL">FUCOM</tt> will handle them silently and
        set the condition code flags to an <span class=
        "QUOTE">"unordered"</span> result, whereas <tt class=
        "LITERAL">FCOM</tt> will generate an exception.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FCOS">B.4.34 <tt class=
        "LITERAL">FCOS</tt>: Cosine</a></h2>
<pre class="SCREEN">
    FCOS                          ; D9 FF                [386,FPU]
</pre>

        <p><tt class="LITERAL">FCOS</tt> computes the cosine of <tt
        class="REGISTER">ST0</tt> (in radians), and stores the
        result in <tt class="REGISTER">ST0</tt>. The absolute value
        of <tt class="REGISTER">ST0</tt> must be less than
        2<sup>63</sup>.</p>

        <p>See also <tt class="LITERAL">FSINCOS</tt> (<a href=
        "inst-ref-general.html#INST-REF-FSIN">Section
        B.4.59</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FDECSTP">B.4.35 <tt
        class="LITERAL">FDECSTP</tt>: Decrement Floating-Point
        Stack Pointer</a></h2>
<pre class="SCREEN">
    FDECSTP                       ; D9 F6                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FDECSTP</tt> decrements the `top'
        field in the floating-point status word. This has the
        effect of rotating the FPU register stack by one, as if the
        contents of <tt class="REGISTER">ST7</tt> had been pushed
        on the stack. See also <tt class="LITERAL">FINCSTP</tt> (<a
        href="inst-ref-general.html#INST-REF-FINCSTP">Section
        B.4.44</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FDISI">B.4.36 <tt
        class="LITERAL">FxDISI</tt>, <tt class=
        "LITERAL">FxENI</tt>: Disable and Enable Floating-Point
        Interrupts</a></h2>
<pre class="SCREEN">
    FDISI                         ; 9B DB E1             [8086,FPU]
    FNDISI                        ; DB E1                [8086,FPU]
    
    FENI                          ; 9B DB E0             [8086,FPU]
    FNENI                         ; DB E0                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FDISI</tt> and <tt class=
        "LITERAL">FENI</tt> disable and enable floating-point
        interrupts. These instructions are only meaningful on
        original 8087 processors: the 287 and above treat them as
        no-operation instructions.</p>

        <p><tt class="LITERAL">FNDISI</tt> and <tt class=
        "LITERAL">FNENI</tt> do the same thing as <tt class=
        "LITERAL">FDISI</tt> and <tt class="LITERAL">FENI</tt>
        respectively, but without waiting for the floating-point
        processor to finish what it was doing first.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FDIV">B.4.37 <tt class=
        "LITERAL">FDIV</tt>, <tt class="LITERAL">FDIVP</tt>, <tt
        class="LITERAL">FDIVR</tt>, <tt class=
        "LITERAL">FDIVRP</tt>: Floating-Point Division</a></h2>
<pre class="SCREEN">
    FDIV mem32                    ; D8 /6                [8086,FPU]
    FDIV mem64                    ; DC /6                [8086,FPU]
    
    FDIV fpureg                   ; D8 F0+r              [8086,FPU]
    FDIV ST0,fpureg               ; D8 F0+r              [8086,FPU]
    
    FDIV TO fpureg                ; DC F8+r              [8086,FPU]
    FDIV fpureg,ST0               ; DC F8+r              [8086,FPU]
    
    FDIVR mem32                   ; D8 /0                [8086,FPU]
    FDIVR mem64                   ; DC /0                [8086,FPU]
    
    FDIVR fpureg                  ; D8 F8+r              [8086,FPU]
    FDIVR ST0,fpureg              ; D8 F8+r              [8086,FPU]
    
    FDIVR TO fpureg               ; DC F0+r              [8086,FPU]
    FDIVR fpureg,ST0              ; DC F0+r              [8086,FPU]
    
    FDIVP fpureg                  ; DE F8+r              [8086,FPU]
    FDIVP fpureg,ST0              ; DE F8+r              [8086,FPU]
    
    FDIVRP fpureg                 ; DE F0+r              [8086,FPU]
    FDIVRP fpureg,ST0             ; DE F0+r              [8086,FPU]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">FDIV</tt> divides <tt class=
            "REGISTER">ST0</tt> by the given operand and stores the
            result back in <tt class="REGISTER">ST0</tt>, unless
            the <tt class="LITERAL">TO</tt> qualifier is given, in
            which case it divides the given operand by <tt class=
            "REGISTER">ST0</tt> and stores the result in the
            operand.</p>
          </li>

          <li>
            <p><tt class="LITERAL">FDIVR</tt> does the same thing,
            but does the division the other way up: so if <tt
            class="LITERAL">TO</tt> is not given, it divides the
            given operand by <tt class="REGISTER">ST0</tt> and
            stores the result in <tt class="REGISTER">ST0</tt>,
            whereas if <tt class="LITERAL">TO</tt> is given it
            divides <tt class="REGISTER">ST0</tt> by its operand
            and stores the result in the operand.</p>
          </li>

          <li>
            <p><tt class="LITERAL">FDIVP</tt> operates like <tt
            class="LITERAL">FDIV TO</tt>, but pops the register
            stack once it has finished.</p>
          </li>

          <li>
            <p><tt class="LITERAL">FDIVRP</tt> operates like <tt
            class="LITERAL">FDIVR TO</tt>, but pops the register
            stack once it has finished.</p>
          </li>
        </ul>

        <p>For FP/Integer divisions, see <tt class=
        "LITERAL">FIDIV</tt> (<a href=
        "inst-ref-general.html#INST-REF-FIDIV">Section
        B.4.41</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FFREE">B.4.38 <tt
        class="LITERAL">FFREE</tt>: Flag Floating-Point Register as
        Unused</a></h2>
<pre class="SCREEN">
    FFREE fpureg                  ; DD C0+r              [8086,FPU]
    FFREEP fpureg                 ; DF C0+r              [286,FPU,UNDOC]
</pre>

        <p><tt class="LITERAL">FFREE</tt> marks the given register
        as being empty.</p>

        <p><tt class="LITERAL">FFREEP</tt> marks the given register
        as being empty, and then pops the register stack.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FIADD">B.4.39 <tt
        class="LITERAL">FIADD</tt>: Floating-Point/Integer
        Addition</a></h2>
<pre class="SCREEN">
    FIADD mem16                   ; DE /0                [8086,FPU]
    FIADD mem32                   ; DA /0                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FIADD</tt> adds the 16-bit or 32-bit
        integer stored in the given memory location to <tt class=
        "REGISTER">ST0</tt>, storing the result in <tt class=
        "REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FICOM">B.4.40 <tt
        class="LITERAL">FICOM</tt>, <tt class=
        "LITERAL">FICOMP</tt>: Floating-Point/Integer
        Compare</a></h2>
<pre class="SCREEN">
    FICOM mem16                   ; DE /2                [8086,FPU]
    FICOM mem32                   ; DA /2                [8086,FPU]
    
    FICOMP mem16                  ; DE /3                [8086,FPU]
    FICOMP mem32                  ; DA /3                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FICOM</tt> compares <tt class=
        "REGISTER">ST0</tt> with the 16-bit or 32-bit integer
        stored in the given memory location, and sets the FPU flags
        accordingly. <tt class="LITERAL">FICOMP</tt> does the same,
        but pops the register stack afterwards.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FIDIV">B.4.41 <tt
        class="LITERAL">FIDIV</tt>, <tt class=
        "LITERAL">FIDIVR</tt>: Floating-Point/Integer
        Division</a></h2>
<pre class="SCREEN">
    FIDIV mem16                   ; DE /6                [8086,FPU]
    FIDIV mem32                   ; DA /6                [8086,FPU]
    
    FIDIVR mem16                  ; DE /7                [8086,FPU]
    FIDIVR mem32                  ; DA /7                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FIDIV</tt> divides <tt class=
        "REGISTER">ST0</tt> by the 16-bit or 32-bit integer stored
        in the given memory location, and stores the result in <tt
        class="REGISTER">ST0</tt>. <tt class="LITERAL">FIDIVR</tt>
        does the division the other way up: it divides the integer
        by <tt class="REGISTER">ST0</tt>, but still stores the
        result in <tt class="REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FILD">B.4.42 <tt class=
        "LITERAL">FILD</tt>, <tt class="LITERAL">FIST</tt>, <tt
        class="LITERAL">FISTP</tt>: Floating-Point/Integer
        Conversion</a></h2>
<pre class="SCREEN">
    FILD mem16                    ; DF /0                [8086,FPU]
    FILD mem32                    ; DB /0                [8086,FPU]
    FILD mem64                    ; DF /5                [8086,FPU]
    
    FIST mem16                    ; DF /2                [8086,FPU]
    FIST mem32                    ; DB /2                [8086,FPU]
    
    FISTP mem16                   ; DF /3                [8086,FPU]
    FISTP mem32                   ; DB /3                [8086,FPU]
    FISTP mem64                   ; DF /7                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FILD</tt> loads an integer out of a
        memory location, converts it to a real, and pushes it on
        the FPU register stack. <tt class="LITERAL">FIST</tt>
        converts <tt class="REGISTER">ST0</tt> to an integer and
        stores that in memory; <tt class="LITERAL">FISTP</tt> does
        the same as <tt class="LITERAL">FIST</tt>, but pops the
        register stack afterwards.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FIMUL">B.4.43 <tt
        class="LITERAL">FIMUL</tt>: Floating-Point/Integer
        Multiplication</a></h2>
<pre class="SCREEN">
    FIMUL mem16                   ; DE /1                [8086,FPU]
    FIMUL mem32                   ; DA /1                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FIMUL</tt> multiplies <tt class=
        "REGISTER">ST0</tt> by the 16-bit or 32-bit integer stored
        in the given memory location, and stores the result in <tt
        class="REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FINCSTP">B.4.44 <tt
        class="LITERAL">FINCSTP</tt>: Increment Floating-Point
        Stack Pointer</a></h2>
<pre class="SCREEN">
    FINCSTP                       ; D9 F7                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FINCSTP</tt> increments the `top'
        field in the floating-point status word. This has the
        effect of rotating the FPU register stack by one, as if the
        register stack had been popped; however, unlike the popping
        of the stack performed by many FPU instructions, it does
        not flag the new <tt class="REGISTER">ST7</tt> (previously
        <tt class="REGISTER">ST0</tt>) as empty. See also <tt
        class="LITERAL">FDECSTP</tt> (<a href=
        "inst-ref-general.html#INST-REF-FDECSTP">Section
        B.4.35</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FINIT">B.4.45 <tt
        class="LITERAL">FINIT</tt>, <tt class=
        "LITERAL">FNINIT</tt>: Initialise Floating-Point
        Unit</a></h2>
<pre class="SCREEN">
    FINIT                         ; 9B DB E3             [8086,FPU]
    FNINIT                        ; DB E3                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FINIT</tt> initialises the FPU to
        its default state. It flags all registers as empty, without
        actually changing their values. <tt class=
        "LITERAL">FNINIT</tt> does the same, without first waiting
        for pending exceptions to clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FISUB">B.4.46 <tt
        class="LITERAL">FISUB</tt>: Floating-Point/Integer
        Subtraction</a></h2>
<pre class="SCREEN">
    FISUB mem16                   ; DE /4                [8086,FPU]
    FISUB mem32                   ; DA /4                [8086,FPU]
    
    FISUBR mem16                  ; DE /5                [8086,FPU]
    FISUBR mem32                  ; DA /5                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FISUB</tt> subtracts the 16-bit or
        32-bit integer stored in the given memory location from <tt
        class="REGISTER">ST0</tt>, and stores the result in <tt
        class="REGISTER">ST0</tt>. <tt class="LITERAL">FISUBR</tt>
        does the subtraction the other way round, i.e. it subtracts
        <tt class="REGISTER">ST0</tt> from the given integer, but
        still stores the result in <tt class=
        "REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FLD">B.4.47 <tt class=
        "LITERAL">FLD</tt>: Floating-Point Load</a></h2>
<pre class="SCREEN">
    FLD mem32                     ; D9 /0                [8086,FPU]
    FLD mem64                     ; DD /0                [8086,FPU]
    FLD mem80                     ; DB /5                [8086,FPU]
    FLD fpureg                    ; D9 C0+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FLD</tt> loads a floating-point
        value out of the given register or memory location, and
        pushes it on the FPU register stack.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FLDXX">B.4.48 <tt
        class="LITERAL">FLDxx</tt>: Floating-Point Load
        Constants</a></h2>
<pre class="SCREEN">
    FLD1                          ; D9 E8                [8086,FPU]
    FLDL2E                        ; D9 EA                [8086,FPU]
    FLDL2T                        ; D9 E9                [8086,FPU]
    FLDLG2                        ; D9 EC                [8086,FPU]
    FLDLN2                        ; D9 ED                [8086,FPU]
    FLDPI                         ; D9 EB                [8086,FPU]
    FLDZ                          ; D9 EE                [8086,FPU]
</pre>

        <p>These instructions push specific standard constants on
        the FPU register stack:</p>

        <div class="INFORMALTABLE">
          <a name="AEN13257"></a>

          <table border="0" class="CALSTABLE">
            <thead>
              <tr>
                <th width="50%" align="LEFT" valign="TOP">
                Instruction</th>

                <th width="50%" align="LEFT" valign="TOP">Constant
                pushed</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLD1</tt></td>

                <td width="50%" align="LEFT" valign="TOP">1.0</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDL2E</tt></td>

                <td width="50%" align="LEFT" valign="TOP">base-2
                logarithm of e</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDL2T</tt></td>

                <td width="50%" align="LEFT" valign="TOP">base-2
                log of 10</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDLG2</tt></td>

                <td width="50%" align="LEFT" valign="TOP">base-10
                log of 2</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDLN2</tt></td>

                <td width="50%" align="LEFT" valign="TOP">base-e
                log of 2</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDPI</tt></td>

                <td width="50%" align="LEFT" valign="TOP">pi</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP"><tt
                class="LITERAL">FLDZ</tt></td>

                <td width="50%" align="LEFT" valign="TOP">zero</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FLDCW">B.4.49 <tt
        class="LITERAL">FLDCW</tt>: Load Floating-Point Control
        Word</a></h2>
<pre class="SCREEN">
    FLDCW mem16                   ; D9 /5                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FLDCW</tt> loads a 16-bit value out
        of memory and stores it into the FPU control word
        (governing things like the rounding mode, the precision,
        and the exception masks). See also <tt class=
        "LITERAL">FSTCW</tt> (<a href=
        "inst-ref-general.html#INST-REF-FSTCW">Section B.4.62</a>).
        If instructions are enabled and you don't want to generate
        one, use <tt class="LITERAL">FCLEX</tt> or <tt class=
        "LITERAL">FNCLEX</tt> (<a href=
        "inst-ref-general.html#INST-REF-FCLEX">Section B.4.31</a>)
        before loading the new control word.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FLDENV">B.4.50 <tt
        class="LITERAL">FLDENV</tt>: Load Floating-Point
        Environment</a></h2>
<pre class="SCREEN">
    FLDENV mem                    ; D9 /4                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FLDENV</tt> loads the FPU operating
        environment (control word, status word, tag word,
        instruction pointer, data pointer and last opcode) from
        memory. The memory area is 14 or 28 bytes long, depending
        on the CPU mode at the time. See also <tt class=
        "LITERAL">FSTENV</tt> (<a href=
        "inst-ref-general.html#INST-REF-FSTENV">Section
        B.4.63</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FMUL">B.4.51 <tt class=
        "LITERAL">FMUL</tt>, <tt class="LITERAL">FMULP</tt>:
        Floating-Point Multiply</a></h2>
<pre class="SCREEN">
    FMUL mem32                    ; D8 /1                [8086,FPU]
    FMUL mem64                    ; DC /1                [8086,FPU]
    
    FMUL fpureg                   ; D8 C8+r              [8086,FPU]
    FMUL ST0,fpureg               ; D8 C8+r              [8086,FPU]
    
    FMUL TO fpureg                ; DC C8+r              [8086,FPU]
    FMUL fpureg,ST0               ; DC C8+r              [8086,FPU]
    
    FMULP fpureg                  ; DE C8+r              [8086,FPU]
    FMULP fpureg,ST0              ; DE C8+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FMUL</tt> multiplies <tt class=
        "REGISTER">ST0</tt> by the given operand, and stores the
        result in <tt class="REGISTER">ST0</tt>, unless the <tt
        class="LITERAL">TO</tt> qualifier is used in which case it
        stores the result in the operand. <tt class=
        "LITERAL">FMULP</tt> performs the same operation as <tt
        class="LITERAL">FMUL TO</tt>, and then pops the register
        stack.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FNOP">B.4.52 <tt class=
        "LITERAL">FNOP</tt>: Floating-Point No Operation</a></h2>
<pre class="SCREEN">
    FNOP                          ; D9 D0                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FNOP</tt> does nothing.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FPATAN">B.4.53 <tt
        class="LITERAL">FPATAN</tt>, <tt class=
        "LITERAL">FPTAN</tt>: Arctangent and Tangent</a></h2>
<pre class="SCREEN">
    FPATAN                        ; D9 F3                [8086,FPU]
    FPTAN                         ; D9 F2                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FPATAN</tt> computes the arctangent,
        in radians, of the result of dividing <tt class=
        "REGISTER">ST1</tt> by <tt class="REGISTER">ST0</tt>,
        stores the result in <tt class="REGISTER">ST1</tt>, and
        pops the register stack. It works like the C <tt class=
        "LITERAL">atan2</tt> function, in that changing the sign of
        both <tt class="REGISTER">ST0</tt> and <tt class=
        "REGISTER">ST1</tt> changes the output value by pi (so it
        performs true rectangular-to-polar coordinate conversion,
        with <tt class="REGISTER">ST1</tt> being the Y coordinate
        and <tt class="REGISTER">ST0</tt> being the X coordinate,
        not merely an arctangent).</p>

        <p><tt class="LITERAL">FPTAN</tt> computes the tangent of
        the value in <tt class="REGISTER">ST0</tt> (in radians),
        and stores the result back into <tt class=
        "REGISTER">ST0</tt>.</p>

        <p>The absolute value of <tt class="REGISTER">ST0</tt> must
        be less than 2<sup>63</sup>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FPREM">B.4.54 <tt
        class="LITERAL">FPREM</tt>, <tt class=
        "LITERAL">FPREM1</tt>: Floating-Point Partial
        Remainder</a></h2>
<pre class="SCREEN">
    FPREM                         ; D9 F8                [8086,FPU]
    FPREM1                        ; D9 F5                [386,FPU]
</pre>

        <p>These instructions both produce the remainder obtained
        by dividing <tt class="REGISTER">ST0</tt> by <tt class=
        "REGISTER">ST1</tt>. This is calculated, notionally, by
        dividing <tt class="REGISTER">ST0</tt> by <tt class=
        "REGISTER">ST1</tt>, rounding the result to an integer,
        multiplying by <tt class="REGISTER">ST1</tt> again, and
        computing the value which would need to be added back on to
        the result to get back to the original value in <tt class=
        "REGISTER">ST0</tt>.</p>

        <p>The two instructions differ in the way the notional
        round-to-integer operation is performed. <tt class=
        "LITERAL">FPREM</tt> does it by rounding towards zero, so
        that the remainder it returns always has the same sign as
        the original value in <tt class="REGISTER">ST0</tt>; <tt
        class="LITERAL">FPREM1</tt> does it by rounding to the
        nearest integer, so that the remainder always has at most
        half the magnitude of <tt class="REGISTER">ST1</tt>.</p>

        <p>Both instructions calculate <span class="emphasis"><i
        class="EMPHASIS">partial</i></span> remainders, meaning
        that they may not manage to provide the final result, but
        might leave intermediate results in <tt class=
        "REGISTER">ST0</tt> instead. If this happens, they will set
        the C2 flag in the FPU status word; therefore, to calculate
        a remainder, you should repeatedly execute <tt class=
        "LITERAL">FPREM</tt> or <tt class="LITERAL">FPREM1</tt>
        until C2 becomes clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FRNDINT">B.4.55 <tt
        class="LITERAL">FRNDINT</tt>: Floating-Point Round to
        Integer</a></h2>
<pre class="SCREEN">
    FRNDINT                       ; D9 FC                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FRNDINT</tt> rounds the contents of
        <tt class="REGISTER">ST0</tt> to an integer, according to
        the current rounding mode set in the FPU control word, and
        stores the result back in <tt class=
        "REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FRSTOR">B.4.56 <tt
        class="LITERAL">FSAVE</tt>, <tt class=
        "LITERAL">FRSTOR</tt>: Save/Restore Floating-Point
        State</a></h2>
<pre class="SCREEN">
    FSAVE mem                     ; 9B DD /6             [8086,FPU]
    FNSAVE mem                    ; DD /6                [8086,FPU]
    
    FRSTOR mem                    ; DD /4                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSAVE</tt> saves the entire
        floating-point unit state, including all the information
        saved by <tt class="LITERAL">FSTENV</tt> (<a href=
        "inst-ref-general.html#INST-REF-FSTENV">Section B.4.63</a>)
        plus the contents of all the registers, to a 94 or 108 byte
        area of memory (depending on the CPU mode). <tt class=
        "LITERAL">FRSTOR</tt> restores the floating-point state
        from the same area of memory.</p>

        <p><tt class="LITERAL">FNSAVE</tt> does the same as <tt
        class="LITERAL">FSAVE</tt>, without first waiting for
        pending floating-point exceptions to clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSCALE">B.4.57 <tt
        class="LITERAL">FSCALE</tt>: Scale Floating-Point Value by
        Power of Two</a></h2>
<pre class="SCREEN">
    FSCALE                        ; D9 FD                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSCALE</tt> scales a number by a
        power of two: it rounds <tt class="REGISTER">ST1</tt>
        towards zero to obtain an integer, then multiplies <tt
        class="REGISTER">ST0</tt> by two to the power of that
        integer, and stores the result in <tt class=
        "REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSETPM">B.4.58 <tt
        class="LITERAL">FSETPM</tt>: Set Protected Mode</a></h2>
<pre class="SCREEN">
    FSETPM                        ; DB E4                [286,FPU]
</pre>

        <p>This instruction initializes protected mode on the 287
        floating-point coprocessor. It is only meaningful on that
        processor: the 387 and above treat the instruction as a
        no-operation.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSIN">B.4.59 <tt class=
        "LITERAL">FSIN</tt>, <tt class="LITERAL">FSINCOS</tt>: Sine
        and Cosine</a></h2>
<pre class="SCREEN">
    FSIN                          ; D9 FE                [386,FPU]
    FSINCOS                       ; D9 FB                [386,FPU]
</pre>

        <p><tt class="LITERAL">FSIN</tt> calculates the sine of <tt
        class="REGISTER">ST0</tt> (in radians) and stores the
        result in <tt class="REGISTER">ST0</tt>. <tt class=
        "LITERAL">FSINCOS</tt> does the same, but then pushes the
        cosine of the same value on the register stack, so that the
        sine ends up in <tt class="REGISTER">ST1</tt> and the
        cosine in <tt class="REGISTER">ST0</tt>. <tt class=
        "LITERAL">FSINCOS</tt> is faster than executing <tt class=
        "LITERAL">FSIN</tt> and <tt class="LITERAL">FCOS</tt> (see
        <a href="inst-ref-general.html#INST-REF-FCOS">Section
        B.4.34</a>) in succession.</p>

        <p>The absolute value of <tt class="REGISTER">ST0</tt> must
        be less than 2<sup>63</sup>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSQRT">B.4.60 <tt
        class="LITERAL">FSQRT</tt>: Floating-Point Square
        Root</a></h2>
<pre class="SCREEN">
    FSQRT                         ; D9 FA                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSQRT</tt> calculates the square
        root of <tt class="REGISTER">ST0</tt> and stores the result
        in <tt class="REGISTER">ST0</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FST">B.4.61 <tt class=
        "LITERAL">FST</tt>, <tt class="LITERAL">FSTP</tt>:
        Floating-Point Store</a></h2>
<pre class="SCREEN">
    FST mem32                     ; D9 /2                [8086,FPU]
    FST mem64                     ; DD /2                [8086,FPU]
    FST fpureg                    ; DD D0+r              [8086,FPU]
    
    FSTP mem32                    ; D9 /3                [8086,FPU]
    FSTP mem64                    ; DD /3                [8086,FPU]
    FSTP mem80                    ; DB /7                [8086,FPU]
    FSTP fpureg                   ; DD D8+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FST</tt> stores the value in <tt
        class="REGISTER">ST0</tt> into the given memory location or
        other FPU register. <tt class="LITERAL">FSTP</tt> does the
        same, but then pops the register stack.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSTCW">B.4.62 <tt
        class="LITERAL">FSTCW</tt>: Store Floating-Point Control
        Word</a></h2>
<pre class="SCREEN">
    FSTCW mem16                   ; 9B D9 /7             [8086,FPU]
    FNSTCW mem16                  ; D9 /7                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSTCW</tt> stores the <tt class=
        "REGISTER">FPU</tt> control word (governing things like the
        rounding mode, the precision, and the exception masks) into
        a 2-byte memory area. See also <tt class=
        "LITERAL">FLDCW</tt> (<a href=
        "inst-ref-general.html#INST-REF-FLDCW">Section
        B.4.49</a>).</p>

        <p><tt class="LITERAL">FNSTCW</tt> does the same thing as
        <tt class="LITERAL">FSTCW</tt>, without first waiting for
        pending floating-point exceptions to clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSTENV">B.4.63 <tt
        class="LITERAL">FSTENV</tt>: Store Floating-Point
        Environment</a></h2>
<pre class="SCREEN">
    FSTENV mem                    ; 9B D9 /6             [8086,FPU]
    FNSTENV mem                   ; D9 /6                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSTENV</tt> stores the <tt class=
        "REGISTER">FPU</tt> operating environment (control word,
        status word, tag word, instruction pointer, data pointer
        and last opcode) into memory. The memory area is 14 or 28
        bytes long, depending on the CPU mode at the time. See also
        <tt class="LITERAL">FLDENV</tt> (<a href=
        "inst-ref-general.html#INST-REF-FLDENV">Section
        B.4.50</a>).</p>

        <p><tt class="LITERAL">FNSTENV</tt> does the same thing as
        <tt class="LITERAL">FSTENV</tt>, without first waiting for
        pending floating-point exceptions to clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSTSW">B.4.64 <tt
        class="LITERAL">FSTSW</tt>: Store Floating-Point Status
        Word</a></h2>
<pre class="SCREEN">
    FSTSW mem16                   ; 9B DD /7             [8086,FPU]
    FSTSW AX                      ; 9B DF E0             [286,FPU]
    
    FNSTSW mem16                  ; DD /7                [8086,FPU]
    FNSTSW AX                     ; DF E0                [286,FPU]
</pre>

        <p><tt class="LITERAL">FSTSW</tt> stores the <tt class=
        "REGISTER">FPU</tt> status word into <tt class=
        "REGISTER">AX</tt> or into a 2-byte memory area.</p>

        <p><tt class="LITERAL">FNSTSW</tt> does the same thing as
        <tt class="LITERAL">FSTSW</tt>, without first waiting for
        pending floating-point exceptions to clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FSUB">B.4.65 <tt class=
        "LITERAL">FSUB</tt>, <tt class="LITERAL">FSUBP</tt>, <tt
        class="LITERAL">FSUBR</tt>, <tt class=
        "LITERAL">FSUBRP</tt>: Floating-Point Subtract</a></h2>
<pre class="SCREEN">
    FSUB mem32                    ; D8 /4                [8086,FPU]
    FSUB mem64                    ; DC /4                [8086,FPU]
    
    FSUB fpureg                   ; D8 E0+r              [8086,FPU]
    FSUB ST0,fpureg               ; D8 E0+r              [8086,FPU]
    
    FSUB TO fpureg                ; DC E8+r              [8086,FPU]
    FSUB fpureg,ST0               ; DC E8+r              [8086,FPU]
    
    FSUBR mem32                   ; D8 /5                [8086,FPU]
    FSUBR mem64                   ; DC /5                [8086,FPU]
    
    FSUBR fpureg                  ; D8 E8+r              [8086,FPU]
    FSUBR ST0,fpureg              ; D8 E8+r              [8086,FPU]
    
    FSUBR TO fpureg               ; DC E0+r              [8086,FPU]
    FSUBR fpureg,ST0              ; DC E0+r              [8086,FPU]
    
    FSUBP fpureg                  ; DE E8+r              [8086,FPU]
    FSUBP fpureg,ST0              ; DE E8+r              [8086,FPU]
    
    FSUBRP fpureg                 ; DE E0+r              [8086,FPU]
    FSUBRP fpureg,ST0             ; DE E0+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FSUB</tt> subtracts the given
        operand from <tt class="REGISTER">ST0</tt> and stores the
        result back in <tt class="REGISTER">ST0</tt>, unless the
        <tt class="LITERAL">TO</tt> qualifier is given, in which
        case it subtracts <tt class="REGISTER">ST0</tt> from the
        given operand and stores the result in the operand.</p>

        <p><tt class="LITERAL">FSUBR</tt> does the same thing, but
        does the subtraction the other way up: so if <tt class=
        "LITERAL">TO</tt> is not given, it subtracts <tt class=
        "REGISTER">ST0</tt> from the given operand and stores the
        result in <tt class="REGISTER">ST0</tt>, whereas if <tt
        class="LITERAL">TO</tt> is given it subtracts its operand
        from <tt class="REGISTER">ST0</tt> and stores the result in
        the operand.</p>

        <p><tt class="LITERAL">FSUBP</tt> operates like <tt class=
        "LITERAL">FSUB TO</tt>, but pops the register stack once it
        has finished.</p>

        <p><tt class="LITERAL">FSUBRP</tt> operates like <tt class=
        "LITERAL">FSUBR TO</tt>, but pops the register stack once
        it has finished.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FTST">B.4.66 <tt class=
        "LITERAL">FTST</tt>: Test <tt class="REGISTER">ST0</tt>
        Against Zero</a></h2>
<pre class="SCREEN">
    FTST                          ; D9 E4                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FTST</tt> compares <tt class=
        "REGISTER">ST0</tt> with zero and sets the FPU flags
        accordingly. <tt class="REGISTER">ST0</tt> is treated as
        the left-hand side of the comparison, so that a <span
        class="QUOTE">"less-than"</span> result is generated if <tt
        class="REGISTER">ST0</tt> is negative.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FUCOM">B.4.67 <tt
        class="LITERAL">FUCOMxx</tt>: Floating-Point Unordered
        Compare</a></h2>
<pre class="SCREEN">
    FUCOM fpureg                  ; DD E0+r              [386,FPU]
    FUCOM ST0,fpureg              ; DD E0+r              [386,FPU]
    
    FUCOMP fpureg                 ; DD E8+r              [386,FPU]
    FUCOMP ST0,fpureg             ; DD E8+r              [386,FPU]
    
    FUCOMPP                       ; DA E9                [386,FPU]
    
    FUCOMI fpureg                 ; DB E8+r              [P6,FPU]
    FUCOMI ST0,fpureg             ; DB E8+r              [P6,FPU]
    
    FUCOMIP fpureg                ; DF E8+r              [P6,FPU]
    FUCOMIP ST0,fpureg            ; DF E8+r              [P6,FPU]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">FUCOM</tt> compares <tt class=
            "REGISTER">ST0</tt> with the given operand, and sets
            the <tt class="REGISTER">FPU</tt> flags accordingly.
            <tt class="REGISTER">ST0</tt> is treated as the
            left-hand side of the comparison, so that the carry
            flag is set (for a <span class=
            "QUOTE">"less-than"</span> result) if <tt class=
            "REGISTER">ST0</tt> is less than the given operand.</p>
          </li>

          <li>
            <p><tt class="LITERAL">FUCOMP</tt> does the same as <tt
            class="LITERAL">FUCOM</tt>, but pops the register stack
            afterwards. <tt class="LITERAL">FUCOMPP</tt> compares
            <tt class="REGISTER">ST0</tt> with <tt class=
            "REGISTER">ST1</tt> and then pops the register stack
            twice.</p>
          </li>

          <li>
            <p><tt class="LITERAL">FUCOMI</tt> and <tt class=
            "LITERAL">FUCOMIP</tt> work like the corresponding
            forms of <tt class="LITERAL">FUCOM</tt> and <tt class=
            "LITERAL">FUCOMP</tt>, but write their results directly
            to the CPU flags register rather than the <tt class=
            "REGISTER">FPU</tt> status word, so they can be
            immediately followed by conditional jump or conditional
            move instructions.</p>
          </li>
        </ul>

        <p>The <tt class="LITERAL">FUCOM</tt> instructions differ
        from the <tt class="LITERAL">FCOM</tt> instructions (<a
        href="inst-ref-general.html#INST-REF-FCOM">Section
        B.4.33</a>) only in the way they handle quiet NaNs: <tt
        class="LITERAL">FUCOM</tt> will handle them silently and
        set the condition code flags to an <span class=
        "QUOTE">"unordered"</span> result, whereas <tt class=
        "LITERAL">FCOM</tt> will generate an exception.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FXAM">B.4.68 <tt class=
        "LITERAL">FXAM</tt>: Examine Class of Value in <tt class=
        "REGISTER">ST0</tt></a></h2>
<pre class="SCREEN">
    FXAM                          ; D9 E5                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FXAM</tt> sets the FPU flags C3, C2
        and C0 depending on the type of value stored in <tt class=
        "REGISTER">ST0</tt>:</p>

        <div class="INFORMALTABLE">
          <a name="AEN13659"></a>

          <table border="0" class="CALSTABLE">
            <thead>
              <tr>
                <th width="50%" align="LEFT" valign="TOP">Register
                contents</th>

                <th width="50%" align="LEFT" valign="TOP">
                Flags</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td width="50%" align="LEFT" valign="TOP">
                Unsupported format</td>

                <td width="50%" align="LEFT" valign="TOP">000</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">NaN</td>

                <td width="50%" align="LEFT" valign="TOP">001</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">Finite
                number</td>

                <td width="50%" align="LEFT" valign="TOP">010</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">
                Infinity</td>

                <td width="50%" align="LEFT" valign="TOP">011</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">Zero</td>

                <td width="50%" align="LEFT" valign="TOP">100</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">Empty
                register</td>

                <td width="50%" align="LEFT" valign="TOP">101</td>
              </tr>

              <tr>
                <td width="50%" align="LEFT" valign="TOP">
                Denormal</td>

                <td width="50%" align="LEFT" valign="TOP">110</td>
              </tr>
            </tbody>
          </table>
        </div>

        <p>Additionally, the <tt class="LITERAL">C1</tt> flag is
        set to the sign of the number.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FXCH">B.4.69 <tt class=
        "LITERAL">FXCH</tt>: Floating-Point Exchange</a></h2>
<pre class="SCREEN">
    FXCH                          ; D9 C9                [8086,FPU]
    FXCH fpureg                   ; D9 C8+r              [8086,FPU]
    FXCH fpureg,ST0               ; D9 C8+r              [8086,FPU]
    FXCH ST0,fpureg               ; D9 C8+r              [8086,FPU]
</pre>

        <p><tt class="LITERAL">FXCH</tt> exchanges <tt class=
        "REGISTER">ST0</tt> with a given FPU register. The
        no-operand form exchanges <tt class="REGISTER">ST0</tt>
        with <tt class="REGISTER">ST1</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FXRSTOR">B.4.70 <tt
        class="LITERAL">FXRSTOR</tt>: Restore <tt class=
        "REGISTER">FPU</tt>, <tt class="REGISTER">MMX</tt>, and <tt
        class="REGISTER">XMM</tt> State</a></h2>
<pre class="SCREEN">
    FXRSTOR memory           ; 0F,AE,/1               [P6,SSE,FPU]
</pre>

        <p>The <tt class="LITERAL">FXRSTOR</tt> instruction reloads
        the <tt class="REGISTER">FPU</tt>, <tt class=
        "REGISTER">MMX</tt>, and <tt class="REGISTER">XMM</tt>
        states (environment and registers), from the 512-byte
        memory area defined by the source operand. This data should
        have been written by a previous <tt class=
        "LITERAL">FXSAVE</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FXSAVE">B.4.71 <tt
        class="LITERAL">FXSAVE</tt>: Store <tt class=
        "REGISTER">FPU</tt>, <tt class="REGISTER">MMX</tt>, and <tt
        class="REGISTER">XMM</tt> State</a></h2>
<pre class="SCREEN">
    FXSAVE memory           ; 0F,AE,/0         [P6,SSE,FPU]
</pre>

        <p><tt class="LITERAL">FXSAVE</tt>The FXSAVE instruction
        writes the current <tt class="REGISTER">FPU</tt>, <tt
        class="REGISTER">MMX</tt>, and <tt class=
        "REGISTER">XMM</tt> states (environment and registers) to
        the specified 512-byte destination defined by the
        destination operand. It does this without checking for
        pending unmasked floating-point exceptions (similar to the
        operation of <tt class="LITERAL">FNSAVE</tt>).</p>

        <p>Unlike the <tt class="LITERAL">FSAVE</tt>/<tt class=
        "LITERAL">FNSAVE</tt> instructions, the processor retains
        the contents of the <tt class="REGISTER">FPU</tt>, <tt
        class="REGISTER">MMX</tt>, and <tt class=
        "REGISTER">XMM</tt> state in the processor after the state
        has been saved. This instruction has been optimized to
        maximize floating-point save performance.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FXTRACT">B.4.72 <tt
        class="LITERAL">FXTRACT</tt>: Extract Exponent and
        Significand</a></h2>
<pre class="SCREEN">
    FXTRACT                       ; D9 F4                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FXTRACT</tt> separates the number in
        <tt class="REGISTER">ST0</tt> into its exponent and
        significand (mantissa), stores the exponent back into <tt
        class="REGISTER">ST0</tt>, and then pushes the significand
        on the register stack (so that the significand ends up in
        <tt class="REGISTER">ST0</tt>, and the exponent in <tt
        class="REGISTER">ST1</tt>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-FYL2X">B.4.73 <tt
        class="LITERAL">FYL2X</tt>, <tt class=
        "LITERAL">FYL2XP1</tt>: Compute Y times Log2(X) or
        Log2(X+1)</a></h2>
<pre class="SCREEN">
    FYL2X                         ; D9 F1                [8086,FPU]
    FYL2XP1                       ; D9 F9                [8086,FPU]
</pre>

        <p><tt class="LITERAL">FYL2X</tt> multiplies <tt class=
        "REGISTER">ST1</tt> by the base-2 logarithm of <tt class=
        "REGISTER">ST0</tt>, stores the result in <tt class=
        "REGISTER">ST1</tt>, and pops the register stack (so that
        the result ends up in <tt class="REGISTER">ST0</tt>). <tt
        class="REGISTER">ST0</tt> must be non-zero and
        positive.</p>

        <p><tt class="LITERAL">FYL2XP1</tt> works the same way, but
        replacing the base-2 log of <tt class="REGISTER">ST0</tt>
        with that of <tt class="REGISTER">ST0</tt> plus one. This
        time, <tt class="REGISTER">ST0</tt> must have magnitude no
        greater than 1 minus half the square root of two.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-HLT">B.4.74 <tt class=
        "LITERAL">HLT</tt>: Halt Processor</a></h2>
<pre class="SCREEN">
    HLT                           ; F4                   [8086,PRIV]
</pre>

        <p><tt class="LITERAL">HLT</tt> puts the processor into a
        halted state, where it will perform no more operations
        until restarted by an interrupt or a reset.</p>

        <p>On the 286 and later processors, this is a privileged
        instruction.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-IDIV">B.4.75 <tt class=
        "LITERAL">IDIV</tt>: Signed Integer Divide</a></h2>
<pre class="SCREEN">
    IDIV r/m8                     ; F6 /7                [8086]
    IDIV r/m16                    ; o16 F7 /7            [8086]
    IDIV r/m32                    ; o32 F7 /7            [386]
</pre>

        <p><tt class="LITERAL">IDIV</tt> performs signed integer
        division. The explicit operand provided is the divisor; the
        dividend and destination operands are implicit, in the
        following way:</p>

        <ul>
          <li>
            <p>For <tt class="LITERAL">IDIV r/m8</tt>, <tt class=
            "REGISTER">AX</tt> is divided by the given operand; the
            quotient is stored in <tt class="REGISTER">AL</tt> and
            the remainder in <tt class="REGISTER">AH</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">IDIV r/m16</tt>, <tt class=
            "LITERAL"><tt class="REGISTER">DX</tt>:<tt class=
            "REGISTER">AX</tt></tt> is divided by the given
            operand; the quotient is stored in <tt class=
            "REGISTER">AX</tt> and the remainder in <tt class=
            "REGISTER">DX</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">IDIV r/m32</tt>, <tt class=
            "LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
            "REGISTER">EAX</tt></tt> is divided by the given
            operand; the quotient is stored in <tt class=
            "REGISTER">EAX</tt> and the remainder in <tt class=
            "REGISTER">EDX</tt>.</p>
          </li>
        </ul>

        <p>Unsigned integer division is performed by the <tt class=
        "LITERAL">DIV</tt> instruction: see <a href=
        "inst-ref-general.html#INST-REF-DIV">Section
        B.4.23</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-IMUL">B.4.76 <tt class=
        "LITERAL">IMUL</tt>: Signed Integer Multiply</a></h2>
<pre class="SCREEN">
    IMUL r/m8                     ; F6 /5                [8086]
    IMUL r/m16                    ; o16 F7 /5            [8086]
    IMUL r/m32                    ; o32 F7 /5            [386]
    
    IMUL reg16,r/m16              ; o16 0F AF /r         [386]
    IMUL reg32,r/m32              ; o32 0F AF /r         [386]
    
    IMUL reg16,imm8               ; o16 6B /r ib         [186]
    IMUL reg16,imm16              ; o16 69 /r iw         [186]
    IMUL reg32,imm8               ; o32 6B /r ib         [386]
    IMUL reg32,imm32              ; o32 69 /r id         [386]
    
    IMUL reg16,r/m16,imm8         ; o16 6B /r ib         [186]
    IMUL reg16,r/m16,imm16        ; o16 69 /r iw         [186]
    IMUL reg32,r/m32,imm8         ; o32 6B /r ib         [386]
    IMUL reg32,r/m32,imm32        ; o32 69 /r id         [386]
</pre>

        <p><tt class="LITERAL">IMUL</tt> performs signed integer
        multiplication. For the single-operand form, the other
        operand and destination are implicit, in the following
        way:</p>

        <ul>
          <li>
            <p>For <tt class="LITERAL">IMUL r/m8</tt>, <tt class=
            "REGISTER">AL</tt> is multiplied by the given operand;
            the product is stored in <tt class=
            "REGISTER">AX</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">IMUL r/m16</tt>, <tt class=
            "REGISTER">AX</tt> is multiplied by the given operand;
            the product is stored in <tt class="LITERAL"><tt class=
            "REGISTER">DX</tt>:<tt class=
            "REGISTER">AX</tt></tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">IMUL r/m32</tt>, <tt class=
            "REGISTER">EAX</tt> is multiplied by the given operand;
            the product is stored in <tt class="LITERAL"><tt class=
            "REGISTER">EDX</tt>:<tt class=
            "REGISTER">EAX</tt></tt>.</p>
          </li>
        </ul>

        <p>The two-operand form multiplies its two operands and
        stores the result in the destination (first) operand. The
        three-operand form multiplies its last two operands and
        stores the result in the first operand.</p>

        <p>The two-operand form with an immediate second operand is
        in fact a shorthand for the three-operand form, as can be
        seen by examining the opcode descriptions: in the
        two-operand form, the code <tt class="LITERAL">/r</tt>
        takes both its register and <tt class="LITERAL">r/m</tt>
        parts from the same operand (the first one).</p>

        <p>In the forms with an 8-bit immediate operand and another
        longer source operand, the immediate operand is considered
        to be signed, and is sign-extended to the length of the
        other source operand. In these cases, the <tt class=
        "LITERAL">BYTE</tt> qualifier is necessary to force NASM to
        generate this form of the instruction.</p>

        <p>Unsigned integer multiplication is performed by the <tt
        class="LITERAL">MUL</tt> instruction: see <a href=
        "inst-ref-general.html#INST-REF-MUL">Section
        B.4.105</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-IN">B.4.77 <tt class=
        "LITERAL">IN</tt>: Input from I/O Port</a></h2>
<pre class="SCREEN">
    IN AL,imm8                    ; E4 ib                [8086]
    IN AX,imm8                    ; o16 E5 ib            [8086]
    IN EAX,imm8                   ; o32 E5 ib            [386]
    IN AL,DX                      ; EC                   [8086]
    IN AX,DX                      ; o16 ED               [8086]
    IN EAX,DX                     ; o32 ED               [386]
</pre>

        <p><tt class="LITERAL">IN</tt> reads a byte, word or
        doubleword from the specified I/O port, and stores it in
        the given destination register. The port number may be
        specified as an immediate value if it is between 0 and 255,
        and otherwise must be stored in <tt class=
        "LITERAL">DX</tt>. See also <tt class="LITERAL">OUT</tt>
        (<a href="inst-ref-general.html#INST-REF-OUT">Section
        B.4.109</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INC">B.4.78 <tt class=
        "LITERAL">INC</tt>: Increment Integer</a></h2>
<pre class="SCREEN">
    INC reg16                     ; o16 40+r             [8086]
    INC reg32                     ; o32 40+r             [386]
    INC r/m8                      ; FE /0                [8086]
    INC r/m16                     ; o16 FF /0            [8086]
    INC r/m32                     ; o32 FF /0            [386]
</pre>

        <p><tt class="LITERAL">INC</tt> adds 1 to its operand. It
        does <span class="emphasis"><i class=
        "EMPHASIS">not</i></span> affect the carry flag: to affect
        the carry flag, use <tt class="LITERAL">ADD
        something,1</tt> (see <a href=
        "inst-ref-general.html#INST-REF-ADD">Section B.4.3</a>).
        <tt class="LITERAL">INC</tt> affects all the other flags
        according to the result.</p>

        <p>This instruction can be used with the <tt class=
        "LITERAL">LOCK</tt> prefix to allow atomic execution.</p>

        <p>See also <tt class="LITERAL">DEC</tt> (<a href=
        "inst-ref-general.html#INST-REF-DEC">Section
        B.4.22</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INSB">B.4.79 <tt class=
        "LITERAL">INSB</tt>, <tt class="LITERAL">INSW</tt>, <tt
        class="LITERAL">INSD</tt>: Input String from I/O
        Port</a></h2>
<pre class="SCREEN">
    INSB                          ; 6C                   [186]
    INSW                          ; o16 6D               [186]
    INSD                          ; o32 6D               [386]
</pre>

        <p><tt class="LITERAL">INSB</tt> inputs a byte from the I/O
        port specified in <tt class="REGISTER">DX</tt> and stores
        it at <tt class="LITERAL">[<tt class="REGISTER">ES</tt>:<tt
        class="REGISTER">DI</tt>]</tt> or <tt class="LITERAL">[<tt
        class="REGISTER">ES</tt>:<tt class=
        "REGISTER">EDI</tt>]</tt>. It then increments or decrements
        (depending on the direction flag: increments if the flag is
        clear, decrements if it is set) <tt class=
        "REGISTER">DI</tt> or <tt class="REGISTER">EDI</tt>.</p>

        <p>The register used is <tt class="REGISTER">DI</tt> if the
        address size is 16 bits, and <tt class="REGISTER">EDI</tt>
        if it is 32 bits. If you need to use an address size not
        equal to the current <tt class="LITERAL">BITS</tt> setting,
        you can use an explicit <tt class="LITERAL">a16</tt> or <tt
        class="LITERAL">a32</tt> prefix.</p>

        <p>Segment override prefixes have no effect for this
        instruction: the use of <tt class="REGISTER">ES</tt> for
        the load from <tt class="LITERAL">[DI]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">EDI</tt>]</tt> cannot be
        overridden.</p>

        <p><tt class="LITERAL">INSW</tt> and <tt class=
        "LITERAL">INSD</tt> work in the same way, but they input a
        word or a doubleword instead of a byte, and increment or
        decrement the addressing register by 2 or 4 instead of
        1.</p>

        <p>The <tt class="LITERAL">REP</tt> prefix may be used to
        repeat the instruction <tt class="REGISTER">CX</tt> (or <tt
        class="REGISTER">ECX</tt> - again, the address size chooses
        which) times.</p>

        <p>See also <tt class="LITERAL">OUTSB</tt>, <tt class=
        "LITERAL">OUTSW</tt> and <tt class="LITERAL">OUTSD</tt> (<a
        href="inst-ref-general.html#INST-REF-OUTSB">Section
        B.4.110</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INT">B.4.80 <tt class=
        "LITERAL">INT</tt>: Software Interrupt</a></h2>
<pre class="SCREEN">
    INT imm8                      ; CD ib                [8086]
</pre>

        <p><tt class="LITERAL">INT</tt> causes a software interrupt
        through a specified vector number from 0 to 255.</p>

        <p>The code generated by the <tt class="LITERAL">INT</tt>
        instruction is always two bytes long: although there are
        short forms for some <tt class="LITERAL">INT</tt>
        instructions, NASM does not generate them when it sees the
        <tt class="LITERAL">INT</tt> mnemonic. In order to generate
        single-byte breakpoint instructions, use the <tt class=
        "LITERAL">INT3</tt> or <tt class="LITERAL">INT1</tt>
        instructions (see <a href=
        "inst-ref-general.html#INST-REF-INT1">Section B.4.81</a>)
        instead.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INT1">B.4.81 <tt class=
        "LITERAL">INT3</tt>, <tt class="LITERAL">INT1</tt>, <tt
        class="LITERAL">ICEBP</tt>, <tt class="LITERAL">INT01</tt>:
        Breakpoints</a></h2>
<pre class="SCREEN">
    INT1                          ; F1                   [P6]
    ICEBP                         ; F1                   [P6]
    INT01                         ; F1                   [P6]
    
    INT3                          ; CC                   [8086]
    INT03                         ; CC                   [8086]
</pre>

        <p><tt class="LITERAL">INT1</tt> and <tt class=
        "LITERAL">INT3</tt> are short one-byte forms of the
        instructions <tt class="LITERAL">INT 1</tt> and <tt class=
        "LITERAL">INT 3</tt> (see <a href=
        "inst-ref-general.html#INST-REF-INT">Section B.4.80</a>).
        They perform a similar function to their longer
        counterparts, but take up less code space. They are used as
        breakpoints by debuggers.</p>

        <p><tt class="LITERAL">INT1</tt>, and its alternative
        synonyms <tt class="LITERAL">INT01</tt> and <tt class=
        "LITERAL">ICEBP</tt>, is an instruction used by in-circuit
        emulators (ICEs). It is present, though not documented, on
        some processors down to the 286, but is only documented for
        the Pentium Pro. <tt class="LITERAL">INT3</tt> is the
        instruction normally used as a breakpoint by debuggers.</p>

        <p><tt class="LITERAL">INT3</tt> and its synonym <tt class=
        "LITERAL">INT03</tt> are not precisely equivalent to <tt
        class="LITERAL">INT 3</tt>: the short form, since it is
        designed to be used as a breakpoint, bypasses the normal
        <tt class="LITERAL">IOPL</tt> checks in virtual-8086 mode,
        and also does not go through interrupt redirection.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INTO">B.4.82 <tt class=
        "LITERAL">INTO</tt>: Interrupt if Overflow</a></h2>
<pre class="SCREEN">
    INTO                          ; CE                   [8086]
</pre>

        <p><tt class="LITERAL">INTO</tt> performs an <tt class=
        "LITERAL">INT 4</tt> software interrupt (see <a href=
        "inst-ref-general.html#INST-REF-INT">Section B.4.80</a>) if
        and only if the overflow flag is set.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INVD">B.4.83 <tt class=
        "LITERAL">INVD</tt>: Invalidate Internal Caches</a></h2>
<pre class="SCREEN">
    INVD                          ; 0F 08                [486]
</pre>

        <p><tt class="LITERAL">INVD</tt> invalidates and empties
        the processor's internal caches, and causes the processor
        to instruct external caches to do the same. It does not
        write the contents of the caches back to memory first: any
        modified data held in the caches will be lost. To write the
        data back first, use <tt class="LITERAL">WBINVD</tt> (<a
        href="inst-ref-general.html#INST-REF-WBINVD">Section
        B.4.148</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-INVLPG">B.4.84 <tt
        class="LITERAL">INVLPG</tt>: Invalidate TLB Entry</a></h2>
<pre class="SCREEN">
    INVLPG mem                    ; 0F 01 /7             [486]
</pre>

        <p><tt class="LITERAL">INVLPG</tt> invalidates the
        translation lookahead buffer (TLB) entry associated with
        the supplied memory address.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-IRET">B.4.85 <tt class=
        "LITERAL">IRET</tt>, <tt class="LITERAL">IRETW</tt>, <tt
        class="LITERAL">IRETD</tt>: Return from Interrupt</a></h2>
<pre class="SCREEN">
    IRET                          ; CF                   [8086]
    IRETW                         ; o16 CF               [8086]
    IRETD                         ; o32 CF               [386]
</pre>

        <p><tt class="LITERAL">IRET</tt> returns from an interrupt
        (hardware or software) by means of popping <tt class=
        "REGISTER">IP</tt> (or <tt class="REGISTER">EIP</tt>), <tt
        class="REGISTER">CS</tt>, and the flags off the stack and
        then continuing execution from the new <tt class=
        "LITERAL"><tt class="REGISTER">CS</tt>:<tt class=
        "REGISTER">IP</tt></tt>.</p>

        <p><tt class="LITERAL">IRETW</tt> pops <tt class=
        "REGISTER">IP</tt>, <tt class="REGISTER">CS</tt> and the
        flags as 2 bytes each, taking 6 bytes off the stack in
        total. <tt class="LITERAL">IRETD</tt> pops <tt class=
        "REGISTER">EIP</tt> as 4 bytes, pops a further 4 bytes of
        which the top two are discarded and the bottom two go into
        <tt class="REGISTER">CS</tt>, and pops the flags as 4 bytes
        as well, taking 12 bytes off the stack.</p>

        <p><tt class="LITERAL">IRET</tt> is a shorthand for either
        <tt class="LITERAL">IRETW</tt> or <tt class=
        "LITERAL">IRETD</tt>, depending on the default <tt class=
        "LITERAL">BITS</tt> setting at the time.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-JCXZ">B.4.86 <tt class=
        "LITERAL">JCXZ</tt>, <tt class="LITERAL">JECXZ</tt>: Jump
        if CX/ECX Zero</a></h2>
<pre class="SCREEN">
    JCXZ imm                      ; a16 E3 rb            [8086]
    JECXZ imm                     ; a32 E3 rb            [386]
</pre>

        <p><tt class="LITERAL">JCXZ</tt> performs a short jump
        (with maximum range 128 bytes) if and only if the contents
        of the <tt class="REGISTER">CX</tt> register is 0. <tt
        class="LITERAL">JECXZ</tt> does the same thing, but with
        <tt class="REGISTER">ECX</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-JCC">B.4.87 <tt class=
        "LITERAL">Jcc</tt>: Conditional Branch</a></h2>
<pre class="SCREEN">
    Jcc imm                       ; 70+cc rb             [8086]
    Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386]
</pre>

        <p>The conditional jump instructions execute a near (same
        segment) jump if and only if their conditions are
        satisfied. For example, <tt class="LITERAL">JNZ</tt> jumps
        only if the zero flag is not set.</p>

        <p>The ordinary form of the instructions has only a
        128-byte range; the <tt class="LITERAL">NEAR</tt> form is a
        386 extension to the instruction set, and can span the full
        size of a segment. NASM will not override your choice of
        jump instruction: if you want <tt class="LITERAL">Jcc
        NEAR</tt>, you have to use the <tt class=
        "LITERAL">NEAR</tt> keyword.</p>

        <p>The <tt class="LITERAL">SHORT</tt> keyword is allowed on
        the first form of the instruction, for clarity, but is not
        necessary.</p>

        <p>For details on the condition codes, see <a href=
        "inst-ref-opcode-desc.html#INST-REF-OPCODE-DESC-COND-CODES">
        Section B.2.2</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-JMP">B.4.88 <tt class=
        "LITERAL">JMP</tt>: Jump</a></h2>
<pre class="SCREEN">
    JMP imm                       ; E9 rw/rd             [8086]
    JMP SHORT imm                 ; EB rb                [8086]
    JMP imm:imm16                 ; o16 EA iw iw         [8086]
    JMP imm:imm32                 ; o32 EA id iw         [386]
    JMP FAR mem                   ; o16 FF /5            [8086]
    JMP FAR mem32                 ; o32 FF /5            [386]
    JMP r/m16                     ; o16 FF /4            [8086]
    JMP r/m32                     ; o32 FF /4            [386]
</pre>

        <p><tt class="LITERAL">JMP</tt> jumps to a given address.
        The address may be specified as an absolute segment and
        offset, or as a relative jump within the current
        segment.</p>

        <p><tt class="LITERAL">JMP SHORT imm</tt> has a maximum
        range of 128 bytes, since the displacement is specified as
        only 8 bits, but takes up less code space. NASM does not
        choose when to generate <tt class="LITERAL">JMP SHORT</tt>
        for you: you must explicitly code <tt class=
        "LITERAL">SHORT</tt> every time you want a short jump.</p>

        <p>You can choose between the two immediate far jump forms
        (<tt class="LITERAL">JMP imm:imm</tt>) by the use of the
        <tt class="LITERAL">WORD</tt> and <tt class=
        "LITERAL">DWORD</tt> keywords: <tt class="LITERAL">JMP WORD
        0x1234:0x5678</tt>) or <tt class="LITERAL">JMP DWORD
        0x1234:0x56789abc</tt>.</p>

        <p>The <tt class="LITERAL">JMP FAR mem</tt> forms execute a
        far jump by loading the destination address out of memory.
        The address loaded consists of 16 or 32 bits of offset
        (depending on the operand size), and 16 bits of segment.
        The operand size may be overridden using <tt class=
        "LITERAL">JMP WORD FAR mem</tt> or <tt class="LITERAL">JMP
        DWORD FAR mem</tt>.</p>

        <p>The <tt class="LITERAL">JMP r/m</tt> forms execute a
        near jump (within the same segment), loading the
        destination address out of memory or out of a register. The
        keyword <tt class="LITERAL">NEAR</tt> may be specified, for
        clarity, in these forms, but is not necessary. Again,
        operand size can be overridden using <tt class=
        "LITERAL">JMP WORD mem</tt> or <tt class="LITERAL">JMP
        DWORD mem</tt>.</p>

        <p>As a convenience, NASM does not require you to jump to a
        far symbol by coding the cumbersome <tt class="LITERAL">JMP
        SEG routine:routine</tt>, but instead allows the easier
        synonym <tt class="LITERAL">JMP FAR routine</tt>.</p>

        <p>The <tt class="LITERAL">CALL r/m</tt> forms given above
        are near calls; NASM will accept the <tt class=
        "LITERAL">NEAR</tt> keyword (e.g. <tt class="LITERAL">CALL
        NEAR [address]</tt>), even though it is not strictly
        necessary.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LAHF">B.4.89 <tt class=
        "LITERAL">LAHF</tt>: Load <tt class="REGISTER">AH</tt> from
        Flags</a></h2>
<pre class="SCREEN">
    LAHF                          ; 9F                   [8086]
</pre>

        <p><tt class="LITERAL">LAHF</tt> sets the <tt class=
        "REGISTER">AH</tt> register according to the contents of
        the low byte of the flags word.</p>

        <p>The operation of <tt class="LITERAL">LAHF</tt> is:</p>
<pre class="SCREEN">
    AH &#60;-- SF:ZF:0:AF:0:PF:1:CF
</pre>

        <p>See also <tt class="LITERAL">SAHF</tt> (<a href=
        "inst-ref-general.html#INST-REF-SAHF">Section
        B.4.126</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LAR">B.4.90 <tt class=
        "LITERAL">LAR</tt>: Load Access Rights</a></h2>
<pre class="SCREEN">
    LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV]
    LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV]
</pre>

        <p><tt class="LITERAL">LAR</tt> takes the segment selector
        specified by its source (second) operand, finds the
        corresponding segment descriptor in the GDT or LDT, and
        loads the access-rights byte of the descriptor into its
        destination (first) operand.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LDS">B.4.91 <tt class=
        "LITERAL">LDS</tt>, <tt class="LITERAL">LES</tt>, <tt
        class="LITERAL">LFS</tt>, <tt class="LITERAL">LGS</tt>, <tt
        class="LITERAL">LSS</tt>: Load Far Pointer</a></h2>
<pre class="SCREEN">
    LDS reg16,mem                 ; o16 C5 /r            [8086]
    LDS reg32,mem                 ; o32 C5 /r            [386]
    
    LES reg16,mem                 ; o16 C4 /r            [8086]
    LES reg32,mem                 ; o32 C4 /r            [386]
    
    LFS reg16,mem                 ; o16 0F B4 /r         [386]
    LFS reg32,mem                 ; o32 0F B4 /r         [386]
    
    LGS reg16,mem                 ; o16 0F B5 /r         [386]
    LGS reg32,mem                 ; o32 0F B5 /r         [386]
    
    LSS reg16,mem                 ; o16 0F B2 /r         [386]
    LSS reg32,mem                 ; o32 0F B2 /r         [386]
</pre>

        <p>These instructions load an entire far pointer (16 or 32
        bits of offset, plus 16 bits of segment) out of memory in
        one go. <tt class="LITERAL">LDS</tt>, for example, loads 16
        or 32 bits from the given memory address into the given
        register (depending on the size of the register), then
        loads the <span class="emphasis"><i class=
        "EMPHASIS">next</i></span> 16 bits from memory into <tt
        class="REGISTER">DS</tt>. <tt class="LITERAL">LES</tt>, <tt
        class="LITERAL">LFS</tt>, <tt class="LITERAL">LGS</tt> and
        <tt class="LITERAL">LSS</tt> work in the same way but use
        the other segment registers.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LEA">B.4.92 <tt class=
        "LITERAL">LEA</tt>: Load Effective Address</a></h2>
<pre class="SCREEN">
    LEA reg16,mem                 ; o16 8D /r            [8086]
    LEA reg32,mem                 ; o32 8D /r            [386]
</pre>

        <p><tt class="LITERAL">LEA</tt>, despite its syntax, does
        not access memory. It calculates the effective address
        specified by its second operand as if it were going to load
        or store data from it, but instead it stores the calculated
        address into the register specified by its first operand.
        This can be used to perform quite complex calculations
        (e.g. <tt class="LITERAL">LEA EAX,[EBX+ECX*4+100]</tt>) in
        one instruction.</p>

        <p><tt class="LITERAL">LEA</tt>, despite being a purely
        arithmetic instruction which accesses no memory, still
        requires square brackets around its second operand, as if
        it were a memory reference.</p>

        <p>The size of the calculation is the current <span class=
        "emphasis"><i class="EMPHASIS">address</i></span> size, and
        the size that the result is stored as is the current <span
        class="emphasis"><i class="EMPHASIS">operand</i></span>
        size. If the address and operand size are not the same,
        then if the addressing mode was 32-bits, the low 16-bits
        are stored, and if the address was 16-bits, it is
        zero-extended to 32-bits before storing.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LEAVE">B.4.93 <tt
        class="LITERAL">LEAVE</tt>: Destroy Stack Frame</a></h2>
<pre class="SCREEN">
    LEAVE                         ; C9                   [186]
</pre>

        <p><tt class="LITERAL">LEAVE</tt> destroys a stack frame of
        the form created by the <tt class="LITERAL">ENTER</tt>
        instruction (see <a href=
        "inst-ref-general.html#INST-REF-ENTER">Section B.4.25</a>).
        It is functionally equivalent to <tt class="LITERAL">MOV
        ESP,EBP</tt> followed by <tt class="LITERAL">POP EBP</tt>
        (or <tt class="LITERAL">MOV SP,BP</tt> followed by <tt
        class="LITERAL">POP BP</tt> in 16-bit mode).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LFENCE">B.4.94 <tt
        class="LITERAL">LFENCE</tt>: Load Fence</a></h2>
<pre class="SCREEN">
    LFENCE                        ; 0F AE /5        [WILLAMETTE,SSE2]
</pre>

        <p><tt class="LITERAL">LFENCE</tt> performs a serializing
        operation on all loads from memory that were issued before
        the <tt class="LITERAL">LFENCE</tt> instruction. This
        guarantees that all memory reads before the <tt class=
        "LITERAL">LFENCE</tt> instruction are visible before any
        reads after the <tt class="LITERAL">LFENCE</tt>
        instruction.</p>

        <p><tt class="LITERAL">LFENCE</tt> is ordered respective to
        other <tt class="LITERAL">LFENCE</tt> instruction, <tt
        class="LITERAL">MFENCE</tt>, any memory read and any other
        serializing instruction (such as <tt class=
        "LITERAL">CPUID</tt>).</p>

        <p>Weakly ordered memory types can be used to achieve
        higher processor performance through such techniques as
        out-of-order issue and speculative reads. The degree to
        which a consumer of data recognizes or knows that the data
        is weakly ordered varies among applications and may be
        unknown to the producer of this data. The <tt class=
        "LITERAL">LFENCE</tt> instruction provides a
        performance-efficient way of ensuring load ordering between
        routines that produce weakly-ordered results and routines
        that consume that data.</p>

        <p><tt class="LITERAL">LFENCE</tt> uses the following ModRM
        encoding:</p>
<pre class="SCREEN">
               Mod (7:6)        = 11B
               Reg/Opcode (5:3) = 101B
               R/M (2:0)        = 000B
</pre>

        <p>All other ModRM encodings are defined to be reserved,
        and use of these encodings risks incompatibility with
        future processors.</p>

        <p>see also <tt class="LITERAL">SFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-SFENCE">Section
        B.4.132</a>) and <tt class="LITERAL">MFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-MFENCE">Section
        B.4.101</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LGDT">B.4.95 <tt class=
        "LITERAL">LGDT</tt>, <tt class="LITERAL">LIDT</tt>, <tt
        class="LITERAL">LLDT</tt>: Load Descriptor Tables</a></h2>
<pre class="SCREEN">
    LGDT mem                      ; 0F 01 /2             [286,PRIV]
    LIDT mem                      ; 0F 01 /3             [286,PRIV]
    LLDT r/m16                    ; 0F 00 /2             [286,PRIV]
</pre>

        <p><tt class="LITERAL">LGDT</tt> and <tt class=
        "LITERAL">LIDT</tt> both take a 6-byte memory area as an
        operand: they load a 32-bit linear address and a 16-bit
        size limit from that area (in the opposite order) into the
        <tt class="LITERAL">GDTR</tt> (global descriptor table
        register) or <tt class="LITERAL">IDTR</tt> (interrupt
        descriptor table register). These are the only instructions
        which directly use <span class="emphasis"><i class=
        "EMPHASIS">linear</i></span> addresses, rather than
        segment/offset pairs.</p>

        <p><tt class="LITERAL">LLDT</tt> takes a segment selector
        as an operand. The processor looks up that selector in the
        <tt class="LITERAL">GDT</tt> and stores the limit and base
        address given there into the <tt class="LITERAL">LDTR</tt>
        (local descriptor table register).</p>

        <p>See also <tt class="LITERAL">SGDT</tt>, <tt class=
        "LITERAL">SIDT</tt> and <tt class="LITERAL">SLDT</tt> (<a
        href="inst-ref-general.html#INST-REF-SGDT">Section
        B.4.133</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LMSW">B.4.96 <tt class=
        "LITERAL">LMSW</tt>: Load/Store Machine Status
        Word</a></h2>
<pre class="SCREEN">
    LMSW r/m16                    ; 0F 01 /6             [286,PRIV]
</pre>

        <p><tt class="LITERAL">LMSW</tt> loads the bottom four bits
        of the source operand into the bottom four bits of the <tt
        class="LITERAL">CR0</tt> control register (or the Machine
        Status Word, on 286 processors). See also <tt class=
        "LITERAL">SMSW</tt> (<a href=
        "inst-ref-general.html#INST-REF-SMSW">Section
        B.4.136</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LODSB">B.4.97 <tt
        class="LITERAL">LODSB</tt>, <tt class="LITERAL">LODSW</tt>,
        <tt class="LITERAL">LODSD</tt>: Load from String</a></h2>
<pre class="SCREEN">
    LODSB                         ; AC                   [8086]
    LODSW                         ; o16 AD               [8086]
    LODSD                         ; o32 AD               [386]
</pre>

        <p><tt class="LITERAL">LODSB</tt> loads a byte from <tt
        class="LITERAL">[<tt class="REGISTER">DS</tt>:<tt class=
        "REGISTER">SI</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">DS</tt>:<tt class="REGISTER">ESI</tt>]</tt> into
        <tt class="REGISTER">AL</tt>. It then increments or
        decrements (depending on the direction flag: increments if
        the flag is clear, decrements if it is set) <tt class=
        "REGISTER">SI</tt> or <tt class="REGISTER">ESI</tt>.</p>

        <p>The register used is <tt class="REGISTER">SI</tt> if the
        address size is 16 bits, and <tt class="REGISTER">ESI</tt>
        if it is 32 bits. If you need to use an address size not
        equal to the current <tt class="LITERAL">BITS</tt> setting,
        you can use an explicit <tt class="LITERAL">a16</tt> or <tt
        class="LITERAL">a32</tt> prefix.</p>

        <p>The segment register used to load from <tt class=
        "LITERAL">[<tt class="REGISTER">SI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">ESI</tt>]</tt> can be
        overridden by using a segment register name as a prefix
        (for example, <tt class="LITERAL"><tt class=
        "REGISTER">ES</tt> LODSB</tt>).</p>

        <p><tt class="LITERAL">LODSW</tt> and <tt class=
        "LITERAL">LODSD</tt> work in the same way, but they load a
        word or a doubleword instead of a byte, and increment or
        decrement the addressing registers by 2 or 4 instead of
        1.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LOOP">B.4.98 <tt class=
        "LITERAL">LOOP</tt>, <tt class="LITERAL">LOOPE</tt>, <tt
        class="LITERAL">LOOPZ</tt>, <tt class=
        "LITERAL">LOOPNE</tt>, <tt class="LITERAL">LOOPNZ</tt>:
        Loop with Counter</a></h2>
<pre class="SCREEN">
    LOOP imm                      ; E2 rb                [8086]
    LOOP imm,CX                   ; a16 E2 rb            [8086]
    LOOP imm,ECX                  ; a32 E2 rb            [386]
    
    LOOPE imm                     ; E1 rb                [8086]
    LOOPE imm,CX                  ; a16 E1 rb            [8086]
    LOOPE imm,ECX                 ; a32 E1 rb            [386]
    LOOPZ imm                     ; E1 rb                [8086]
    LOOPZ imm,CX                  ; a16 E1 rb            [8086]
    LOOPZ imm,ECX                 ; a32 E1 rb            [386]
    
    LOOPNE imm                    ; E0 rb                [8086]
    LOOPNE imm,CX                 ; a16 E0 rb            [8086]
    LOOPNE imm,ECX                ; a32 E0 rb            [386]
    LOOPNZ imm                    ; E0 rb                [8086]
    LOOPNZ imm,CX                 ; a16 E0 rb            [8086]
    LOOPNZ imm,ECX                ; a32 E0 rb            [386]
</pre>

        <p><tt class="LITERAL">LOOP</tt> decrements its counter
        register (either <tt class="REGISTER">CX</tt> or <tt class=
        "REGISTER">ECX</tt>--if one is not specified explicitly,
        the <tt class="LITERAL">BITS</tt> setting dictates which is
        used) by one, and if the counter does not become zero as a
        result of this operation, it jumps to the given label. The
        jump has a range of 128 bytes.</p>

        <p><tt class="LITERAL">LOOPE</tt> (or its synonym <tt
        class="LITERAL">LOOPZ</tt>) adds the additional condition
        that it only jumps if the counter is nonzero <span class=
        "emphasis"><i class="EMPHASIS">and</i></span> the zero flag
        is set. Similarly, <tt class="LITERAL">LOOPNE</tt> (and <tt
        class="LITERAL">LOOPNZ</tt>) jumps only if the counter is
        nonzero and the zero flag is clear.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LSL">B.4.99 <tt class=
        "LITERAL">LSL</tt>: Load Segment Limit</a></h2>
<pre class="SCREEN">
    LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV]
    LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV]
</pre>

        <p><tt class="LITERAL">LSL</tt> is given a segment selector
        in its source (second) operand; it computes the segment
        limit value by loading the segment limit field from the
        associated segment descriptor in the <tt class=
        "LITERAL">GDT</tt> or <tt class="LITERAL">LDT</tt>. (This
        involves shifting left by 12 bits if the segment limit is
        page-granular, and not if it is byte-granular; so you end
        up with a byte limit in either case.) The segment limit
        obtained is then loaded into the destination (first)
        operand.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-LTR">B.4.100 <tt class=
        "LITERAL">LTR</tt>: Load Task Register</a></h2>
<pre class="SCREEN">
    LTR r/m16                     ; 0F 00 /3             [286,PRIV]
</pre>

        <p><tt class="LITERAL">LTR</tt> looks up the segment base
        and limit in the GDT or LDT descriptor specified by the
        segment selector given as its operand, and loads them into
        the Task Register.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-MFENCE">B.4.101 <tt
        class="LITERAL">MFENCE</tt>: Memory Fence</a></h2>
<pre class="SCREEN">
    MFENCE                        ; 0F AE /6        [WILLAMETTE,SSE2]
</pre>

        <p><tt class="LITERAL">MFENCE</tt> performs a serializing
        operation on all loads from memory and writes to memory
        that were issued before the <tt class="LITERAL">MFENCE</tt>
        instruction. This guarantees that all memory reads and
        writes before the <tt class="LITERAL">MFENCE</tt>
        instruction are completed before any reads and writes after
        the <tt class="LITERAL">MFENCE</tt> instruction.</p>

        <p><tt class="LITERAL">MFENCE</tt> is ordered respective to
        other <tt class="LITERAL">MFENCE</tt> instructions, <tt
        class="LITERAL">LFENCE</tt>, <tt class=
        "LITERAL">SFENCE</tt>, any memory read and any other
        serializing instruction (such as <tt class=
        "LITERAL">CPUID</tt>).</p>

        <p>Weakly ordered memory types can be used to achieve
        higher processor performance through such techniques as
        out-of-order issue, speculative reads, write-combining, and
        write-collapsing. The degree to which a consumer of data
        recognizes or knows that the data is weakly ordered varies
        among applications and may be unknown to the producer of
        this data. The <tt class="LITERAL">MFENCE</tt> instruction
        provides a performance-efficient way of ensuring load and
        store ordering between routines that produce weakly-ordered
        results and routines that consume that data.</p>

        <p><tt class="LITERAL">MFENCE</tt> uses the following ModRM
        encoding:</p>
<pre class="SCREEN">
              Mod (7:6)        = 11B
               Reg/Opcode (5:3) = 110B
               R/M (2:0)        = 000B
</pre>

        <p>All other ModRM encodings are defined to be reserved,
        and use of these encodings risks incompatibility with
        future processors.</p>

        <p>See also <tt class="LITERAL">LFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-LFENCE">Section B.4.94</a>)
        and <tt class="LITERAL">SFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-SFENCE">Section
        B.4.132</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-MOV">B.4.102 <tt class=
        "LITERAL">MOV</tt>: Move Data</a></h2>
<pre class="SCREEN">
    MOV r/m8,reg8                 ; 88 /r                [8086]
    MOV r/m16,reg16               ; o16 89 /r            [8086]
    MOV r/m32,reg32               ; o32 89 /r            [386]
    MOV reg8,r/m8                 ; 8A /r                [8086]
    MOV reg16,r/m16               ; o16 8B /r            [8086]
    MOV reg32,r/m32               ; o32 8B /r            [386]
    
    MOV reg8,imm8                 ; B0+r ib              [8086]
    MOV reg16,imm16               ; o16 B8+r iw          [8086]
    MOV reg32,imm32               ; o32 B8+r id          [386]
    MOV r/m8,imm8                 ; C6 /0 ib             [8086]
    MOV r/m16,imm16               ; o16 C7 /0 iw         [8086]
    MOV r/m32,imm32               ; o32 C7 /0 id         [386]
    
    MOV AL,memoffs8               ; A0 ow/od             [8086]
    MOV AX,memoffs16              ; o16 A1 ow/od         [8086]
    MOV EAX,memoffs32             ; o32 A1 ow/od         [386]
    MOV memoffs8,AL               ; A2 ow/od             [8086]
    MOV memoffs16,AX              ; o16 A3 ow/od         [8086]
    MOV memoffs32,EAX             ; o32 A3 ow/od         [386]
    
    MOV r/m16,segreg              ; o16 8C /r            [8086]
    MOV r/m32,segreg              ; o32 8C /r            [386]
    MOV segreg,r/m16              ; o16 8E /r            [8086]
    MOV segreg,r/m32              ; o32 8E /r            [386]
    
    MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386]
    MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386]
    MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386]
    MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386]
    MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386]
    MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386]
</pre>

        <p><tt class="LITERAL">MOV</tt> copies the contents of its
        source (second) operand into its destination (first)
        operand.</p>

        <p>In all forms of the <tt class="LITERAL">MOV</tt>
        instruction, the two operands are the same size, except for
        moving between a segment register and an <tt class=
        "LITERAL">r/m32</tt> operand. These instructions are
        treated exactly like the corresponding 16-bit equivalent
        (so that, for example, <tt class="LITERAL">MOV DS,EAX</tt>
        functions identically to <tt class="LITERAL">MOV DS,AX</tt>
        but saves a prefix when in 32-bit mode), except that when a
        segment register is moved into a 32-bit destination, the
        top two bytes of the result are undefined.</p>

        <p><tt class="LITERAL">MOV</tt> may not use <tt class=
        "REGISTER">CS</tt> as a destination.</p>

        <p><tt class="REGISTER">CR4</tt> is only a supported
        register on the Pentium and above.</p>

        <p>Test registers are supported on 386/486 processors and
        on some non-Intel Pentium class processors.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-MOVSB">B.4.103 <tt
        class="LITERAL">MOVSB</tt>, <tt class="LITERAL">MOVSW</tt>,
        <tt class="LITERAL">MOVSD</tt>: Move String</a></h2>
<pre class="SCREEN">
    MOVSB                         ; A4                   [8086]
    MOVSW                         ; o16 A5               [8086]
    MOVSD                         ; o32 A5               [386]
</pre>

        <p><tt class="LITERAL">MOVSB</tt> copies the byte at <tt
        class="LITERAL">[<tt class="REGISTER">DS</tt>:<tt class=
        "REGISTER">SI</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">DS</tt>:<tt class="REGISTER">ESI</tt>]</tt> to
        <tt class="LITERAL">[<tt class="REGISTER">ES</tt>:<tt
        class="REGISTER">DI</tt>]</tt> or <tt class="LITERAL">[<tt
        class="REGISTER">ES</tt>:<tt class=
        "REGISTER">EDI</tt>]</tt>. It then increments or decrements
        (depending on the direction flag: increments if the flag is
        clear, decrements if it is set) <tt class=
        "REGISTER">SI</tt> and <tt class="REGISTER">DI</tt> (or <tt
        class="REGISTER">ESI</tt> and <tt class=
        "REGISTER">EDI</tt>).</p>

        <p>The registers used are <tt class="REGISTER">SI</tt> and
        <tt class="REGISTER">DI</tt> if the address size is 16
        bits, and <tt class="REGISTER">ESI</tt> and <tt class=
        "REGISTER">EDI</tt> if it is 32 bits. If you need to use an
        address size not equal to the current <tt class=
        "LITERAL">BITS</tt> setting, you can use an explicit <tt
        class="LITERAL">a16</tt> or <tt class="LITERAL">a32</tt>
        prefix.</p>

        <p>The segment register used to load from <tt class=
        "LITERAL">[<tt class="REGISTER">SI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">ESI</tt>]</tt> can be
        overridden by using a segment register name as a prefix
        (for example, <tt class="LITERAL">es movsb</tt>). The use
        of <tt class="REGISTER">ES</tt> for the store to <tt class=
        "LITERAL">[<tt class="REGISTER">DI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">EDI</tt>]</tt> cannot be
        overridden.</p>

        <p><tt class="LITERAL">MOVSW</tt> and <tt class=
        "LITERAL">MOVSD</tt> work in the same way, but they copy a
        word or a doubleword instead of a byte, and increment or
        decrement the addressing registers by 2 or 4 instead of
        1.</p>

        <p>The <tt class="LITERAL">REP</tt> prefix may be used to
        repeat the instruction <tt class="REGISTER">CX</tt> (or <tt
        class="REGISTER">ECX</tt> - again, the address size chooses
        which) times.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-MOVSX">B.4.104 <tt
        class="LITERAL">MOVSX</tt>, <tt class="LITERAL">MOVZX</tt>:
        Move Data with Sign or Zero Extend</a></h2>
<pre class="SCREEN">
    MOVSX reg16,r/m8              ; o16 0F BE /r         [386]
    MOVSX reg32,r/m8              ; o32 0F BE /r         [386]
    MOVSX reg32,r/m16             ; o32 0F BF /r         [386]
    
    MOVZX reg16,r/m8              ; o16 0F B6 /r         [386]
    MOVZX reg32,r/m8              ; o32 0F B6 /r         [386]
    MOVZX reg32,r/m16             ; o32 0F B7 /r         [386]
</pre>

        <p><tt class="LITERAL">MOVSX</tt> sign-extends its source
        (second) operand to the length of its destination (first)
        operand, and copies the result into the destination
        operand. <tt class="LITERAL">MOVZX</tt> does the same, but
        zero-extends rather than sign-extending.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-MUL">B.4.105 <tt class=
        "LITERAL">MUL</tt>: Unsigned Integer Multiply</a></h2>
<pre class="SCREEN">
    MUL r/m8                      ; F6 /4                [8086]
    MUL r/m16                     ; o16 F7 /4            [8086]
    MUL r/m32                     ; o32 F7 /4            [386]
</pre>

        <p><tt class="LITERAL">MUL</tt> performs unsigned integer
        multiplication. The other operand to the multiplication,
        and the destination operand, are implicit, in the following
        way:</p>

        <ul>
          <li>
            <p>For <tt class="LITERAL">MUL r/m8</tt>, <tt class=
            "REGISTER">AL</tt> is multiplied by the given operand;
            the product is stored in <tt class=
            "REGISTER">AX</tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">MUL r/m16</tt>, <tt class=
            "REGISTER">AX</tt> is multiplied by the given operand;
            the product is stored in <tt class="LITERAL"><tt class=
            "REGISTER">DX</tt>:<tt class=
            "REGISTER">AX</tt></tt>.</p>
          </li>

          <li>
            <p>For <tt class="LITERAL">MUL r/m32</tt>, <tt class=
            "REGISTER">EAX</tt> is multiplied by the given operand;
            the product is stored in <tt class="LITERAL"><tt class=
            "REGISTER">EDX</tt>:<tt class=
            "REGISTER">EAX</tt></tt>.</p>
          </li>
        </ul>

        <p>Signed integer multiplication is performed by the <tt
        class="LITERAL">IMUL</tt> instruction: see <a href=
        "inst-ref-general.html#INST-REF-IMUL">Section
        B.4.76</a>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-NEG">B.4.106 <tt class=
        "LITERAL">NEG</tt>, <tt class="LITERAL">NOT</tt>: Two's and
        One's Complement</a></h2>
<pre class="SCREEN">
    NEG r/m8                      ; F6 /3                [8086]
    NEG r/m16                     ; o16 F7 /3            [8086]
    NEG r/m32                     ; o32 F7 /3            [386]
    
    NOT r/m8                      ; F6 /2                [8086]
    NOT r/m16                     ; o16 F7 /2            [8086]
    NOT r/m32                     ; o32 F7 /2            [386]
</pre>

        <p><tt class="LITERAL">NEG</tt> replaces the contents of
        its operand by the two's complement negation (invert all
        the bits and then add one) of the original value. <tt
        class="LITERAL">NOT</tt>, similarly, performs one's
        complement (inverts all the bits).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-NOP">B.4.107 <tt class=
        "LITERAL">NOP</tt>: No Operation</a></h2>
<pre class="SCREEN">
    NOP                           ; 90                   [8086]
</pre>

        <p><tt class="LITERAL">NOP</tt> performs no operation. Its
        opcode is the same as that generated by <tt class=
        "LITERAL">XCHG AX,AX</tt> or <tt class="LITERAL">XCHG
        EAX,EAX</tt> (depending on the processor mode; see <a href=
        "inst-ref-general.html#INST-REF-XCHG">Section
        B.4.151</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-OR">B.4.108 <tt class=
        "LITERAL">OR</tt>: Bitwise OR</a></h2>
<pre class="SCREEN">
    OR r/m8,reg8                  ; 08 /r                [8086]
    OR r/m16,reg16                ; o16 09 /r            [8086]
    OR r/m32,reg32                ; o32 09 /r            [386]
    
    OR reg8,r/m8                  ; 0A /r                [8086]
    OR reg16,r/m16                ; o16 0B /r            [8086]
    OR reg32,r/m32                ; o32 0B /r            [386]
    
    OR r/m8,imm8                  ; 80 /1 ib             [8086]
    OR r/m16,imm16                ; o16 81 /1 iw         [8086]
    OR r/m32,imm32                ; o32 81 /1 id         [386]
    
    OR r/m16,imm8                 ; o16 83 /1 ib         [8086]
    OR r/m32,imm8                 ; o32 83 /1 ib         [386]
    
    OR AL,imm8                    ; 0C ib                [8086]
    OR AX,imm16                   ; o16 0D iw            [8086]
    OR EAX,imm32                  ; o32 0D id            [386]
</pre>

        <p><tt class="LITERAL">OR</tt> performs a bitwise OR
        operation between its two operands (i.e. each bit of the
        result is 1 if and only if at least one of the
        corresponding bits of the two inputs was 1), and stores the
        result in the destination (first) operand.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>The MMX instruction <tt class="LITERAL">POR</tt> (see <a
        href="inst-ref-simd.html#INST-REF-POR">Section B.5.55</a>)
        performs the same operation on the 64-bit MMX
        registers.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-OUT">B.4.109 <tt class=
        "LITERAL">OUT</tt>: Output Data to I/O Port</a></h2>
<pre class="SCREEN">
    OUT imm8,AL                   ; E6 ib                [8086]
    OUT imm8,AX                   ; o16 E7 ib            [8086]
    OUT imm8,EAX                  ; o32 E7 ib            [386]
    OUT DX,AL                     ; EE                   [8086]
    OUT DX,AX                     ; o16 EF               [8086]
    OUT DX,EAX                    ; o32 EF               [386]
</pre>

        <p><tt class="LITERAL">OUT</tt> writes the contents of the
        given source register to the specified I/O port. The port
        number may be specified as an immediate value if it is
        between 0 and 255, and otherwise must be stored in <tt
        class="REGISTER">DX</tt>. See also <tt class=
        "LITERAL">IN</tt> (<a href=
        "inst-ref-general.html#INST-REF-IN">Section
        B.4.77</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-OUTSB">B.4.110 <tt
        class="LITERAL">OUTSB</tt>, <tt class="LITERAL">OUTSW</tt>,
        <tt class="LITERAL">OUTSD</tt>: Output String to I/O
        Port</a></h2>
<pre class="SCREEN">
    OUTSB                         ; 6E                   [186]
    OUTSW                         ; o16 6F               [186]
    OUTSD                         ; o32 6F               [386]
</pre>

        <p><tt class="LITERAL">OUTSB</tt> loads a byte from <tt
        class="LITERAL">[<tt class="REGISTER">DS</tt>:<tt class=
        "REGISTER">SI</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">DS</tt>:<tt class="REGISTER">ESI</tt>]</tt> and
        writes it to the I/O port specified in <tt class=
        "LITERAL">DX</tt>. It then increments or decrements
        (depending on the direction flag: increments if the flag is
        clear, decrements if it is set) <tt class=
        "REGISTER">SI</tt> or <tt class="REGISTER">ESI</tt>.</p>

        <p>The register used is <tt class="REGISTER">SI</tt> if the
        address size is 16 bits, and <tt class="REGISTER">ESI</tt>
        if it is 32 bits. If you need to use an address size not
        equal to the current <tt class="LITERAL">BITS</tt> setting,
        you can use an explicit <tt class="LITERAL">a16</tt> or <tt
        class="LITERAL">a32</tt> prefix.</p>

        <p>The segment register used to load from <tt class=
        "LITERAL">[<tt class="REGISTER">SI</tt>]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">ESI</tt>]</tt> can be
        overridden by using a segment register name as a prefix
        (for example, <tt class="LITERAL">es outsb</tt>).</p>

        <p><tt class="LITERAL">OUTSW</tt> and <tt class=
        "LITERAL">OUTSD</tt> work in the same way, but they output
        a word or a doubleword instead of a byte, and increment or
        decrement the addressing registers by 2 or 4 instead of
        1.</p>

        <p>The <tt class="LITERAL">REP</tt> prefix may be used to
        repeat the instruction <tt class="REGISTER">CX</tt> (or <tt
        class="REGISTER">ECX</tt> - again, the address size chooses
        which) times.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-PAUSE">B.4.111 <tt
        class="LITERAL">PAUSE</tt>: Spin Loop Hint</a></h2>
<pre class="SCREEN">
    PAUSE                         ; F3 90           [WILLAMETTE,SSE2]
</pre>

        <p><tt class="LITERAL">PAUSE</tt> provides a hint to the
        processor that the following code is a spin loop. This
        improves processor performance by bypassing possible memory
        order violations. On older processors, this instruction
        operates as a <tt class="LITERAL">NOP</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-POP">B.4.112 <tt class=
        "LITERAL">POP</tt>: Pop Data from Stack</a></h2>
<pre class="SCREEN">
    POP reg16                     ; o16 58+r             [8086]
    POP reg32                     ; o32 58+r             [386]
    
    POP r/m16                     ; o16 8F /0            [8086]
    POP r/m32                     ; o32 8F /0            [386]
    
    POP DS                        ; 1F                   [8086]
    POP ES                        ; 07                   [8086]
    POP SS                        ; 17                   [8086]
    POP FS                        ; 0F A1                [386]
    POP GS                        ; 0F A9                [386]
</pre>

        <p><tt class="LITERAL">POP</tt> loads a value from the
        stack (from <tt class="LITERAL">[<tt class=
        "REGISTER">SS</tt>:<tt class="REGISTER">SP</tt>]</tt> or
        <tt class="LITERAL">[<tt class="REGISTER">SS</tt>:<tt
        class="REGISTER">ESP</tt>]</tt>) and then increments the
        stack pointer.</p>

        <p>The address-size attribute of the instruction determines
        whether <tt class="REGISTER">SP</tt> or <tt class=
        "REGISTER">ESP</tt> is used as the stack pointer: to
        deliberately override the default given by the <tt class=
        "LITERAL">BITS</tt> setting, you can use an <tt class=
        "LITERAL">a16</tt> or <tt class="LITERAL">a32</tt>
        prefix.</p>

        <p>The operand-size attribute of the instruction determines
        whether the stack pointer is incremented by 2 or 4: this
        means that segment register pops in <tt class=
        "LITERAL">BITS 32</tt> mode will pop 4 bytes off the stack
        and discard the upper two of them. If you need to override
        that, you can use an <tt class="LITERAL">o16</tt> or <tt
        class="LITERAL">o32</tt> prefix.</p>

        <p>The above opcode listings give two forms for
        general-purpose register pop instructions: for example, <tt
        class="LITERAL">POP BX</tt> has the two forms <tt class=
        "LITERAL">5B</tt> and <tt class="LITERAL">8F C3</tt>. NASM
        will always generate the shorter form when given <tt class=
        "LITERAL">POP BX</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-POPA">B.4.113 <tt
        class="LITERAL">POPAx</tt>: Pop All General-Purpose
        Registers</a></h2>
<pre class="SCREEN">
    POPA                          ; 61                   [186]
    POPAW                         ; o16 61               [186]
    POPAD                         ; o32 61               [386]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">POPAW</tt> pops a word from the
            stack into each of, successively, <tt class=
            "REGISTER">DI</tt>, <tt class="REGISTER">SI</tt>, <tt
            class="REGISTER">BP</tt>, nothing (it discards a word
            from the stack which was a placeholder for <tt class=
            "REGISTER">SP</tt>), <tt class="REGISTER">BX</tt>, <tt
            class="REGISTER">DX</tt>, <tt class="REGISTER">CX</tt>
            and <tt class="REGISTER">AX</tt>. It is intended to
            reverse the operation of <tt class=
            "LITERAL">PUSHAW</tt> (see <a href=
            "inst-ref-general.html#INST-REF-PUSHA">Section
            B.4.117</a>), but it ignores the value for <tt class=
            "REGISTER">SP</tt> that was pushed on the stack by <tt
            class="LITERAL">PUSHAW</tt>.</p>
          </li>

          <li>
            <p><tt class="LITERAL">POPAD</tt> pops twice as much
            data, and places the results in <tt class=
            "REGISTER">EDI</tt>, <tt class="REGISTER">ESI</tt>, <tt
            class="REGISTER">EBP</tt>, nothing (placeholder for <tt
            class="REGISTER">ESP</tt>), <tt class=
            "REGISTER">EBX</tt>, <tt class="REGISTER">EDX</tt>, <tt
            class="REGISTER">ECX</tt> and <tt class=
            "REGISTER">EAX</tt>. It reverses the operation of <tt
            class="LITERAL">PUSHAD</tt>.</p>
          </li>
        </ul>

        <p><tt class="LITERAL">POPA</tt> is an alias mnemonic for
        either <tt class="LITERAL">POPAW</tt> or <tt class=
        "LITERAL">POPAD</tt>, depending on the current <tt class=
        "LITERAL">BITS</tt> setting.</p>

        <p>Note that the registers are popped in reverse order of
        their numeric values in opcodes (see <a href=
        "inst-ref-opcode-desc.html#INST-REF-OPCODE-DESC-REG-VALUES">
        Section B.2.1</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-POPF">B.4.114 <tt
        class="LITERAL">POPFx</tt>: Pop Flags Register</a></h2>
<pre class="SCREEN">
    POPF                          ; 9D                   [8086]
    POPFW                         ; o16 9D               [8086]
    POPFD                         ; o32 9D               [386]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">POPFW</tt> pops a word from the
            stack and stores it in the bottom 16 bits of the flags
            register (or the whole flags register, on processors
            below a 386). <tt class="LITERAL">POPFD</tt> pops a
            doubleword and stores it in the entire flags
            register.</p>
          </li>

          <li>
            <p><tt class="LITERAL">POPF</tt> is an alias mnemonic
            for either <tt class="LITERAL">POPFW</tt> or <tt class=
            "LITERAL">POPFD</tt>, depending on the current <tt
            class="LITERAL">BITS</tt> setting.</p>
          </li>
        </ul>

        <p>See also <tt class="LITERAL">PUSHF</tt> (<a href=
        "inst-ref-general.html#INST-REF-PUSHF">Section
        B.4.118</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-PREFETCHH">B.4.115 <tt
        class="LITERAL">PREFETCHh</tt>: Prefetch Data Into
        Caches</a></h2>
<pre class="SCREEN">
    PREFETCHNTA m8                ; 0F 18 /0        [KATMAI]
    PREFETCHT0 m8                 ; 0F 18 /1        [KATMAI]
    PREFETCHT1 m8                 ; 0F 18 /2        [KATMAI]
    PREFETCHT2 m8                 ; 0F 18 /3        [KATMAI]
</pre>

        <p>The <tt class="LITERAL">PREFETCHh</tt> instructions
        fetch the line of data from memory that contains the
        specified byte. It is placed in the cache according to
        rules specified by locality hint <tt class=
        "LITERAL">h</tt>:</p>

        <p>The hints are:</p>

        <ul>
          <li>
            <p><tt class="LITERAL">T0</tt> (temporal data) -
            prefetch data into all levels of the cache
            hierarchy.</p>
          </li>

          <li>
            <p><tt class="LITERAL">T1</tt> (temporal data with
            respect to first level cache) - prefetch data into
            level 2 cache and higher.</p>
          </li>

          <li>
            <p><tt class="LITERAL">T2</tt> (temporal data with
            respect to second level cache) - prefetch data into
            level 2 cache and higher.</p>
          </li>

          <li>
            <p><tt class="LITERAL">NTA</tt> (non-temporal data with
            respect to all cache levels) - prefetch data into
            non-temporal cache structure and into a location close
            to the processor, minimizing cache pollution.</p>
          </li>
        </ul>

        <p>Note that this group of instructions doesn't provide a
        guarantee that the data will be in the cache when it is
        needed. For more details, see the Intel IA32 Software
        Developer Manual, Volume 2.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-PUSH">B.4.116 <tt
        class="LITERAL">PUSH</tt>: Push Data on Stack</a></h2>
<pre class="SCREEN">
    PUSH reg16                    ; o16 50+r             [8086]
    PUSH reg32                    ; o32 50+r             [386]
    
    PUSH r/m16                    ; o16 FF /6            [8086]
    PUSH r/m32                    ; o32 FF /6            [386]
    
    PUSH CS                       ; 0E                   [8086]
    PUSH DS                       ; 1E                   [8086]
    PUSH ES                       ; 06                   [8086]
    PUSH SS                       ; 16                   [8086]
    PUSH FS                       ; 0F A0                [386]
    PUSH GS                       ; 0F A8                [386]
    
    PUSH imm8                     ; 6A ib                [186]
    PUSH imm16                    ; o16 68 iw            [186]
    PUSH imm32                    ; o32 68 id            [386]
</pre>

        <p><tt class="LITERAL">PUSH</tt> decrements the stack
        pointer (<tt class="REGISTER">SP</tt> or <tt class=
        "REGISTER">ESP</tt>) by 2 or 4, and then stores the given
        value at <tt class="LITERAL">[<tt class=
        "REGISTER">SS</tt>:<tt class="REGISTER">SP</tt>]</tt> or
        <tt class="LITERAL">[<tt class="REGISTER">SS</tt>:<tt
        class="REGISTER">ESP</tt>]</tt>.</p>

        <p>The address-size attribute of the instruction determines
        whether <tt class="REGISTER">SP</tt> or <tt class=
        "REGISTER">ESP</tt> is used as the stack pointer: to
        deliberately override the default given by the <tt class=
        "LITERAL">BITS</tt> setting, you can use an <tt class=
        "LITERAL">a16</tt> or <tt class="LITERAL">a32</tt>
        prefix.</p>

        <p>The operand-size attribute of the instruction determines
        whether the stack pointer is decremented by 2 or 4: this
        means that segment register pushes in <tt class=
        "LITERAL">BITS 32</tt> mode will push 4 bytes on the stack,
        of which the upper two are undefined. If you need to
        override that, you can use an <tt class="LITERAL">o16</tt>
        or <tt class="LITERAL">o32</tt> prefix.</p>

        <p>The above opcode listings give two forms for
        general-purpose register push instructions: for example,
        <tt class="LITERAL">PUSH BX</tt> has the two forms <tt
        class="LITERAL">53</tt> and <tt class="LITERAL">FF F3</tt>.
        NASM will always generate the shorter form when given <tt
        class="LITERAL">PUSH BX</tt>.</p>

        <p>The instruction <tt class="LITERAL">PUSH SP</tt> may be
        used to distinguish an 8086 from later processors: on an
        8086, the value of <tt class="REGISTER">SP</tt> stored is
        the value it has <span class="emphasis"><i class=
        "EMPHASIS">after</i></span> the push instruction, whereas
        on later processors it is the value <span class=
        "emphasis"><i class="EMPHASIS">before</i></span> the push
        instruction.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-PUSHA">B.4.117 <tt
        class="LITERAL">PUSHAx</tt>: Push All General-Purpose
        Registers</a></h2>
<pre class="SCREEN">
    PUSHA                         ; 60                   [186]
    PUSHAD                        ; o32 60               [386]
    PUSHAW                        ; o16 60               [186]
</pre>

        <p><tt class="LITERAL">PUSHAW</tt> pushes, in succession,
        <tt class="REGISTER">AX</tt>, <tt class="REGISTER">CX</tt>,
        <tt class="REGISTER">DX</tt>, <tt class="REGISTER">BX</tt>,
        <tt class="REGISTER">SP</tt>, <tt class="REGISTER">BP</tt>,
        <tt class="REGISTER">SI</tt> and <tt class=
        "REGISTER">DI</tt> on the stack, decrementing the stack
        pointer by a total of 16.</p>

        <p><tt class="LITERAL">PUSHAD</tt> pushes, in succession,
        <tt class="REGISTER">EAX</tt>, <tt class=
        "REGISTER">ECX</tt>, <tt class="REGISTER">EDX</tt>, <tt
        class="REGISTER">EBX</tt>, <tt class="REGISTER">ESP</tt>,
        <tt class="REGISTER">EBP</tt>, <tt class=
        "REGISTER">ESI</tt> and <tt class="REGISTER">EDI</tt> on
        the stack, decrementing the stack pointer by a total of
        32.</p>

        <p>In both cases, the value of <tt class="REGISTER">SP</tt>
        or <tt class="REGISTER">ESP</tt> pushed is its <span class=
        "emphasis"><i class="EMPHASIS">original</i></span> value,
        as it had before the instruction was executed.</p>

        <p><tt class="LITERAL">PUSHA</tt> is an alias mnemonic for
        either <tt class="LITERAL">PUSHAW</tt> or <tt class=
        "LITERAL">PUSHAD</tt>, depending on the current <tt class=
        "LITERAL">BITS</tt> setting.</p>

        <p>Note that the registers are pushed in order of their
        numeric values in opcodes (see <a href=
        "inst-ref-opcode-desc.html#INST-REF-OPCODE-DESC-REG-VALUES">
        Section B.2.1</a>).</p>

        <p>See also <tt class="LITERAL">POPA</tt> (<a href=
        "inst-ref-general.html#INST-REF-POPA">Section
        B.4.113</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-PUSHF">B.4.118 <tt
        class="LITERAL">PUSHFx</tt>: Push Flags Register</a></h2>
<pre class="SCREEN">
    PUSHF                         ; 9C                   [8086]
    PUSHFD                        ; o32 9C               [386]
    PUSHFW                        ; o16 9C               [8086]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">PUSHFW</tt> pops a word from the
            stack and stores it in the bottom 16 bits of the flags
            register (or the whole flags register, on processors
            below a 386).</p>
          </li>

          <li>
            <p><tt class="LITERAL">PUSHFD</tt> pops a doubleword
            and stores it in the entire flags register.</p>
          </li>
        </ul>

        <p><tt class="LITERAL">PUSHF</tt> is an alias mnemonic for
        either <tt class="LITERAL">PUSHFW</tt> or <tt class=
        "LITERAL">PUSHFD</tt>, depending on the current <tt class=
        "LITERAL">BITS</tt> setting.</p>

        <p>See also <tt class="LITERAL">POPF</tt> (<a href=
        "inst-ref-general.html#INST-REF-POPF">Section
        B.4.114</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RCL">B.4.119 <tt class=
        "LITERAL">RCL</tt>, <tt class="LITERAL">RCR</tt>: Bitwise
        Rotate through Carry Bit</a></h2>
<pre class="SCREEN">
    RCL r/m8,1                    ; D0 /2                [8086]
    RCL r/m8,CL                   ; D2 /2                [8086]
    RCL r/m8,imm8                 ; C0 /2 ib             [186]
    RCL r/m16,1                   ; o16 D1 /2            [8086]
    RCL r/m16,CL                  ; o16 D3 /2            [8086]
    RCL r/m16,imm8                ; o16 C1 /2 ib         [186]
    RCL r/m32,1                   ; o32 D1 /2            [386]
    RCL r/m32,CL                  ; o32 D3 /2            [386]
    RCL r/m32,imm8                ; o32 C1 /2 ib         [386]
    
    RCR r/m8,1                    ; D0 /3                [8086]
    RCR r/m8,CL                   ; D2 /3                [8086]
    RCR r/m8,imm8                 ; C0 /3 ib             [186]
    RCR r/m16,1                   ; o16 D1 /3            [8086]
    RCR r/m16,CL                  ; o16 D3 /3            [8086]
    RCR r/m16,imm8                ; o16 C1 /3 ib         [186]
    RCR r/m32,1                   ; o32 D1 /3            [386]
    RCR r/m32,CL                  ; o32 D3 /3            [386]
    RCR r/m32,imm8                ; o32 C1 /3 ib         [386]
</pre>

        <p><tt class="LITERAL">RCL</tt> and <tt class=
        "LITERAL">RCR</tt> perform a 9-bit, 17-bit or 33-bit
        bitwise rotation operation, involving the given
        source/destination (first) operand and the carry bit. Thus,
        for example, in the operation <tt class="LITERAL">RCL <tt
        class="REGISTER">AL</tt>,1</tt>, a 9-bit rotation is
        performed in which <tt class="REGISTER">AL</tt> is shifted
        left by 1, the top bit of <tt class="REGISTER">AL</tt>
        moves into the carry flag, and the original value of the
        carry flag is placed in the low bit of <tt class=
        "REGISTER">AL</tt>.</p>

        <p>The number of bits to rotate by is given by the second
        operand. Only the bottom five bits of the rotation count
        are considered by processors above the 8086.</p>

        <p>You can force the longer (286 and upwards, beginning
        with a <tt class="LITERAL">C1</tt> byte) form of <tt class=
        "LITERAL">RCL foo,1</tt> by using a <tt class=
        "LITERAL">BYTE</tt> prefix: <tt class="LITERAL">RCL foo,
        BYTE 1</tt>. Similarly with <tt class=
        "LITERAL">RCR</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RDMSR">B.4.120 <tt
        class="LITERAL">RDMSR</tt>: Read Model-Specific
        Registers</a></h2>
<pre class="SCREEN">
    RDMSR                         ; 0F 32                [PENT,PRIV]
</pre>

        <p><tt class="LITERAL">RDMSR</tt> reads the processor
        Model-Specific Register (MSR) whose index is stored in <tt
        class="REGISTER">ECX</tt>, and stores the result in <tt
        class="LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
        "REGISTER">EAX</tt></tt>. See also <tt class=
        "LITERAL">WRMSR</tt> (<a href=
        "inst-ref-general.html#INST-REF-WRMSR">Section
        B.4.149</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RDPMC">B.4.121 <tt
        class="LITERAL">RDPMC</tt>: Read Performance-Monitoring
        Counters</a></h2>
<pre class="SCREEN">
    RDPMC                         ; 0F 33                [P6]
</pre>

        <p><tt class="LITERAL">RDPMC</tt> reads the processor
        performance-monitoring counter whose index is stored in <tt
        class="REGISTER">ECX</tt>, and stores the result in <tt
        class="LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
        "REGISTER">EAX</tt></tt>.</p>

        <p>This instruction is available on P6 and later processors
        and on MMX class processors.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RDTSC">B.4.122 <tt
        class="LITERAL">RDTSC</tt>: Read Time-Stamp
        Counter</a></h2>
<pre class="SCREEN">
    RDTSC                         ; 0F 31                [PENT]
</pre>

        <p><tt class="LITERAL">RDTSC</tt> reads the processor's
        time-stamp counter into <tt class="LITERAL"><tt class=
        "REGISTER">EDX</tt>:<tt class="REGISTER">EAX</tt></tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RET">B.4.123 <tt class=
        "LITERAL">RET</tt>, <tt class="LITERAL">RETF</tt>, <tt
        class="LITERAL">RETN</tt>: Return from Procedure
        Call</a></h2>
<pre class="SCREEN">
    RET                           ; C3                   [8086]
    RET imm16                     ; C2 iw                [8086]
    
    RETF                          ; CB                   [8086]
    RETF imm16                    ; CA iw                [8086]
    
    RETN                          ; C3                   [8086]
    RETN imm16                    ; C2 iw                [8086]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">RET</tt>, and its exact synonym
            <tt class="LITERAL">RETN</tt>, pop <tt class=
            "LITERAL">IP</tt> or <tt class="LITERAL">EIP</tt> from
            the stack and transfer control to the new address.
            Optionally, if a numeric second operand is provided,
            they increment the stack pointer by a further <tt
            class="LITERAL">imm16</tt> bytes after popping the
            return address.</p>
          </li>

          <li>
            <p><tt class="LITERAL">RETF</tt> executes a far return:
            after popping <tt class="LITERAL">IP</tt>/<tt class=
            "LITERAL">EIP</tt>, it then pops <tt class=
            "LITERAL">CS</tt>, and <span class="emphasis"><i class=
            "EMPHASIS">then</i></span> increments the stack pointer
            by the optional argument if present.</p>
          </li>
        </ul>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-ROL">B.4.124 <tt class=
        "LITERAL">ROL</tt>, <tt class="LITERAL">ROR</tt>: Bitwise
        Rotate</a></h2>
<pre class="SCREEN">
    ROL r/m8,1                    ; D0 /0                [8086]
    ROL r/m8,CL                   ; D2 /0                [8086]
    ROL r/m8,imm8                 ; C0 /0 ib             [186]
    ROL r/m16,1                   ; o16 D1 /0            [8086]
    ROL r/m16,CL                  ; o16 D3 /0            [8086]
    ROL r/m16,imm8                ; o16 C1 /0 ib         [186]
    ROL r/m32,1                   ; o32 D1 /0            [386]
    ROL r/m32,CL                  ; o32 D3 /0            [386]
    ROL r/m32,imm8                ; o32 C1 /0 ib         [386]
    
    ROR r/m8,1                    ; D0 /1                [8086]
    ROR r/m8,CL                   ; D2 /1                [8086]
    ROR r/m8,imm8                 ; C0 /1 ib             [186]
    ROR r/m16,1                   ; o16 D1 /1            [8086]
    ROR r/m16,CL                  ; o16 D3 /1            [8086]
    ROR r/m16,imm8                ; o16 C1 /1 ib         [186]
    ROR r/m32,1                   ; o32 D1 /1            [386]
    ROR r/m32,CL                  ; o32 D3 /1            [386]
    ROR r/m32,imm8                ; o32 C1 /1 ib         [386]
</pre>

        <p><tt class="LITERAL">ROL</tt> and <tt class=
        "LITERAL">ROR</tt> perform a bitwise rotation operation on
        the given source/destination (first) operand. Thus, for
        example, in the operation <tt class="LITERAL">ROL <tt
        class="REGISTER">AL</tt>,1</tt>, an 8-bit rotation is
        performed in which <tt class="REGISTER">AL</tt> is shifted
        left by 1 and the original top bit of <tt class=
        "REGISTER">AL</tt> moves round into the low bit.</p>

        <p>The number of bits to rotate by is given by the second
        operand. Only the bottom five bits of the rotation count
        are considered by processors above the 8086.</p>

        <p>You can force the longer (286 and upwards, beginning
        with a <tt class="LITERAL">C1</tt> byte) form of <tt class=
        "LITERAL">ROL foo,1</tt> by using a <tt class=
        "LITERAL">BYTE</tt> prefix: <tt class="LITERAL">ROL
        foo,BYTE 1</tt>. Similarly with <tt class=
        "LITERAL">ROR</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-RSM">B.4.125 <tt class=
        "LITERAL">RSM</tt>: Resume from System-Management
        Mode</a></h2>
<pre class="SCREEN">
    RSM                           ; 0F AA                [PENT]
</pre>

        <p><tt class="LITERAL">RSM</tt> returns the processor to
        its normal operating mode when it was in System-Management
        Mode.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SAHF">B.4.126 <tt
        class="LITERAL">SAHF</tt>: Store AH to Flags</a></h2>
<pre class="SCREEN">
    SAHF                          ; 9E                   [8086]
</pre>

        <p><tt class="LITERAL">SAHF</tt> sets the low byte of the
        flags word according to the contents of the <tt class=
        "REGISTER">AH</tt> register.</p>

        <p>The operation of <tt class="LITERAL">SAHF</tt> is:</p>
<pre class="SCREEN">
    AH --&#62; SF:ZF:0:AF:0:PF:1:CF
</pre>

        <p>See also <tt class="LITERAL">LAHF</tt> (<a href=
        "inst-ref-general.html#INST-REF-LAHF">Section
        B.4.89</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SAL">B.4.127 <tt class=
        "LITERAL">SAL</tt>, <tt class="LITERAL">SAR</tt>: Bitwise
        Arithmetic Shifts</a></h2>
<pre class="SCREEN">
    SAL r/m8,1                    ; D0 /4                [8086]
    SAL r/m8,CL                   ; D2 /4                [8086]
    SAL r/m8,imm8                 ; C0 /4 ib             [186]
    SAL r/m16,1                   ; o16 D1 /4            [8086]
    SAL r/m16,CL                  ; o16 D3 /4            [8086]
    SAL r/m16,imm8                ; o16 C1 /4 ib         [186]
    SAL r/m32,1                   ; o32 D1 /4            [386]
    SAL r/m32,CL                  ; o32 D3 /4            [386]
    SAL r/m32,imm8                ; o32 C1 /4 ib         [386]
    
    SAR r/m8,1                    ; D0 /7                [8086]
    SAR r/m8,CL                   ; D2 /7                [8086]
    SAR r/m8,imm8                 ; C0 /7 ib             [186]
    SAR r/m16,1                   ; o16 D1 /7            [8086]
    SAR r/m16,CL                  ; o16 D3 /7            [8086]
    SAR r/m16,imm8                ; o16 C1 /7 ib         [186]
    SAR r/m32,1                   ; o32 D1 /7            [386]
    SAR r/m32,CL                  ; o32 D3 /7            [386]
    SAR r/m32,imm8                ; o32 C1 /7 ib         [386]
</pre>

        <p><tt class="LITERAL">SAL</tt> and <tt class=
        "LITERAL">SAR</tt> perform an arithmetic shift operation on
        the given source/destination (first) operand. The vacated
        bits are filled with zero for <tt class="LITERAL">SAL</tt>,
        and with copies of the original high bit of the source
        operand for <tt class="LITERAL">SAR</tt>.</p>

        <p><tt class="LITERAL">SAL</tt> is a synonym for <tt class=
        "LITERAL">SHL</tt> (see <a href=
        "inst-ref-general.html#INST-REF-SHL">Section B.4.134</a>).
        NASM will assemble either one to the same code, but NDISASM
        will always disassemble that code as <tt class=
        "LITERAL">SHL</tt>.</p>

        <p>The number of bits to shift by is given by the second
        operand. Only the bottom five bits of the shift count are
        considered by processors above the 8086.</p>

        <p>You can force the longer (286 and upwards, beginning
        with a <tt class="LITERAL">C1</tt> byte) form of <tt class=
        "LITERAL">SAL foo,1</tt> by using a <tt class=
        "LITERAL">BYTE</tt> prefix: <tt class="LITERAL">SAL
        foo,BYTE 1</tt>. Similarly with <tt class=
        "LITERAL">SAR</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SALC">B.4.128 <tt
        class="LITERAL">SALC</tt>: Set AL from Carry Flag</a></h2>
<pre class="SCREEN">
    SALC                          ; D6                  [8086,UNDOC]
</pre>

        <p><tt class="LITERAL">SALC</tt> is an early undocumented
        instruction similar in concept to <tt class=
        "LITERAL">SETcc</tt> (<a href=
        "inst-ref-general.html#INST-REF-SETCC">Section
        B.4.131</a>). Its function is to set <tt class=
        "REGISTER">AL</tt> to zero if the carry flag is clear, or
        to <tt class="LITERAL">0xFF</tt> if it is set.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SBB">B.4.129 <tt class=
        "LITERAL">SBB</tt>: Subtract with Borrow</a></h2>
<pre class="SCREEN">
    SBB r/m8,reg8                 ; 18 /r                [8086]
    SBB r/m16,reg16               ; o16 19 /r            [8086]
    SBB r/m32,reg32               ; o32 19 /r            [386]
    
    SBB reg8,r/m8                 ; 1A /r                [8086]
    SBB reg16,r/m16               ; o16 1B /r            [8086]
    SBB reg32,r/m32               ; o32 1B /r            [386]
    
    SBB r/m8,imm8                 ; 80 /3 ib             [8086]
    SBB r/m16,imm16               ; o16 81 /3 iw         [8086]
    SBB r/m32,imm32               ; o32 81 /3 id         [386]
    
    SBB r/m16,imm8                ; o16 83 /3 ib         [8086]
    SBB r/m32,imm8                ; o32 83 /3 ib         [386]
    
    SBB AL,imm8                   ; 1C ib                [8086]
    SBB AX,imm16                  ; o16 1D iw            [8086]
    SBB EAX,imm32                 ; o32 1D id            [386]
</pre>

        <p><tt class="LITERAL">SBB</tt> performs integer
        subtraction: it subtracts its second operand, plus the
        value of the carry flag, from its first, and leaves the
        result in its destination (first) operand. The flags are
        set according to the result of the operation: in
        particular, the carry flag is affected and can be used by a
        subsequent <tt class="LITERAL">SBB</tt> instruction.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>To subtract one number from another without also
        subtracting the contents of the carry flag, use <tt class=
        "LITERAL">SUB</tt> (<a href=
        "inst-ref-general.html#INST-REF-SUB">Section
        B.4.140</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SCASB">B.4.130 <tt
        class="LITERAL">SCASB</tt>, <tt class="LITERAL">SCASW</tt>,
        <tt class="LITERAL">SCASD</tt>: Scan String</a></h2>
<pre class="SCREEN">
    SCASB                         ; AE                   [8086]
    SCASW                         ; o16 AF               [8086]
    SCASD                         ; o32 AF               [386]
</pre>

        <p><tt class="LITERAL">SCASB</tt> compares the byte in <tt
        class="REGISTER">AL</tt> with the byte at <tt class=
        "LITERAL">[<tt class="REGISTER">ES</tt>:<tt class=
        "REGISTER">DI</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">ES</tt>:<tt class="REGISTER">EDI</tt>]</tt>, and
        sets the flags accordingly. It then increments or
        decrements (depending on the direction flag: increments if
        the flag is clear, decrements if it is set) <tt class=
        "REGISTER">DI</tt> (or <tt class="REGISTER">EDI</tt>).</p>

        <p>The register used is <tt class="REGISTER">DI</tt> if the
        address size is 16 bits, and <tt class="REGISTER">EDI</tt>
        if it is 32 bits. If you need to use an address size not
        equal to the current <tt class="LITERAL">BITS</tt> setting,
        you can use an explicit <tt class="LITERAL">a16</tt> or <tt
        class="LITERAL">a32</tt> prefix.</p>

        <p>Segment override prefixes have no effect for this
        instruction: the use of <tt class="REGISTER">ES</tt> for
        the load from <tt class="LITERAL">[DI]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">EDI</tt>]</tt> cannot be
        overridden.</p>

        <p><tt class="LITERAL">SCASW</tt> and <tt class=
        "LITERAL">SCASD</tt> work in the same way, but they compare
        a word to <tt class="REGISTER">AX</tt> or a doubleword to
        <tt class="REGISTER">EAX</tt> instead of a byte to <tt
        class="REGISTER">AL</tt>, and increment or decrement the
        addressing registers by 2 or 4 instead of 1.</p>

        <p>The <tt class="LITERAL">REPE</tt> and <tt class=
        "LITERAL">REPNE</tt> prefixes (equivalently, <tt class=
        "LITERAL">REPZ</tt> and <tt class="LITERAL">REPNZ</tt>) may
        be used to repeat the instruction up to <tt class=
        "REGISTER">CX</tt> (or <tt class="REGISTER">ECX</tt> -
        again, the address size chooses which) times until the
        first unequal or equal byte is found.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SETCC">B.4.131 <tt
        class="LITERAL">SETcc</tt>: Set Register from
        Condition</a></h2>
<pre class="SCREEN">
    SETcc r/m8                    ; 0F 90+cc /2          [386]
</pre>

        <p><tt class="LITERAL">SETcc</tt> sets the given 8-bit
        operand to zero if its condition is not satisfied, and to 1
        if it is.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SFENCE">B.4.132 <tt
        class="LITERAL">SFENCE</tt>: Store Fence</a></h2>
<pre class="SCREEN">
    SFENCE                 ; 0F AE /7               [KATMAI]
</pre>

        <p><tt class="LITERAL">SFENCE</tt> performs a serialising
        operation on all writes to memory that were issued before
        the <tt class="LITERAL">SFENCE</tt> instruction. This
        guarantees that all memory writes before the <tt class=
        "LITERAL">SFENCE</tt> instruction are visible before any
        writes after the <tt class="LITERAL">SFENCE</tt>
        instruction.</p>

        <p><tt class="LITERAL">SFENCE</tt> is ordered respective to
        other <tt class="LITERAL">SFENCE</tt> instruction, <tt
        class="LITERAL">MFENCE</tt>, any memory write and any other
        serialising instruction (such as <tt class=
        "LITERAL">CPUID</tt>).</p>

        <p>Weakly ordered memory types can be used to achieve
        higher processor performance through such techniques as
        out-of-order issue, write-combining, and write-collapsing.
        The degree to which a consumer of data recognizes or knows
        that the data is weakly ordered varies among applications
        and may be unknown to the producer of this data. The <tt
        class="LITERAL">SFENCE</tt> instruction provides a
        performance-efficient way of insuring store ordering
        between routines that produce weakly-ordered results and
        routines that consume this data.</p>

        <p><tt class="LITERAL">SFENCE</tt> uses the following ModRM
        encoding:</p>
<pre class="SCREEN">
              Mod (7:6)        = 11B
              Reg/Opcode (5:3) = 111B
              R/M (2:0)        = 000B
</pre>

        <p>All other ModRM encodings are defined to be reserved,
        and use of these encodings risks incompatibility with
        future processors.</p>

        <p>See also <tt class="LITERAL">LFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-LFENCE">Section B.4.94</a>)
        and <tt class="LITERAL">MFENCE</tt> (<a href=
        "inst-ref-general.html#INST-REF-MFENCE">Section
        B.4.101</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SGDT">B.4.133 <tt
        class="LITERAL">SGDT</tt>, <tt class="LITERAL">SIDT</tt>,
        <tt class="LITERAL">SLDT</tt>: Store Descriptor Table
        Pointers</a></h2>
<pre class="SCREEN">
    SGDT mem                      ; 0F 01 /0             [286,PRIV]
    SIDT mem                      ; 0F 01 /1             [286,PRIV]
    SLDT r/m16                    ; 0F 00 /0             [286,PRIV]
</pre>

        <p><tt class="LITERAL">SGDT</tt> and <tt class=
        "LITERAL">SIDT</tt> both take a 6-byte memory area as an
        operand: they store the contents of the GDTR (global
        descriptor table register) or IDTR (interrupt descriptor
        table register) into that area as a 32-bit linear address
        and a 16-bit size limit from that area (in that order).
        These are the only instructions which directly use <span
        class="emphasis"><i class="EMPHASIS">linear</i></span>
        addresses, rather than segment/offset pairs.</p>

        <p><tt class="LITERAL">SLDT</tt> stores the segment
        selector corresponding to the LDT (local descriptor table)
        into the given operand.</p>

        <p>See also <tt class="LITERAL">LGDT</tt>, <tt class=
        "LITERAL">LIDT</tt> and <tt class="LITERAL">LLDT</tt> (<a
        href="inst-ref-general.html#INST-REF-LGDT">Section
        B.4.95</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SHL">B.4.134 <tt class=
        "LITERAL">SHL</tt>, <tt class="LITERAL">SHR</tt>: Bitwise
        Logical Shifts</a></h2>
<pre class="SCREEN">
    SHL r/m8,1                    ; D0 /4                [8086]
    SHL r/m8,CL                   ; D2 /4                [8086]
    SHL r/m8,imm8                 ; C0 /4 ib             [186]
    SHL r/m16,1                   ; o16 D1 /4            [8086]
    SHL r/m16,CL                  ; o16 D3 /4            [8086]
    SHL r/m16,imm8                ; o16 C1 /4 ib         [186]
    SHL r/m32,1                   ; o32 D1 /4            [386]
    SHL r/m32,CL                  ; o32 D3 /4            [386]
    SHL r/m32,imm8                ; o32 C1 /4 ib         [386]
    
    SHR r/m8,1                    ; D0 /5                [8086]
    SHR r/m8,CL                   ; D2 /5                [8086]
    SHR r/m8,imm8                 ; C0 /5 ib             [186]
    SHR r/m16,1                   ; o16 D1 /5            [8086]
    SHR r/m16,CL                  ; o16 D3 /5            [8086]
    SHR r/m16,imm8                ; o16 C1 /5 ib         [186]
    SHR r/m32,1                   ; o32 D1 /5            [386]
    SHR r/m32,CL                  ; o32 D3 /5            [386]
    SHR r/m32,imm8                ; o32 C1 /5 ib         [386]
</pre>

        <p><tt class="LITERAL">SHL</tt> and <tt class=
        "LITERAL">SHR</tt> perform a logical shift operation on the
        given source/destination (first) operand. The vacated bits
        are filled with zero.</p>

        <p>A synonym for <tt class="LITERAL">SHL</tt> is <tt class=
        "LITERAL">SAL</tt> (see <a href=
        "inst-ref-general.html#INST-REF-SAL">Section B.4.127</a>).
        NASM will assemble either one to the same code.</p>

        <p>The number of bits to shift by is given by the second
        operand. Only the bottom five bits of the shift count are
        considered by processors above the 8086.</p>

        <p>You can force the longer (286 and upwards, beginning
        with a <tt class="LITERAL">C1</tt> byte) form of <tt class=
        "LITERAL">SHL foo,1</tt> by using a <tt class=
        "LITERAL">BYTE</tt> prefix: <tt class="LITERAL">SHL
        foo,BYTE 1</tt>. Similarly with <tt class=
        "LITERAL">SHR</tt>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SHLD">B.4.135 <tt
        class="LITERAL">SHLD</tt>, <tt class="LITERAL">SHRD</tt>:
        Bitwise Double-Precision Shifts</a></h2>
<pre class="SCREEN">
    SHLD r/m16,reg16,imm8         ; o16 0F A4 /r ib      [386]
    SHLD r/m16,reg32,imm8         ; o32 0F A4 /r ib      [386]
    SHLD r/m16,reg16,CL           ; o16 0F A5 /r         [386]
    SHLD r/m16,reg32,CL           ; o32 0F A5 /r         [386]
    
    SHRD r/m16,reg16,imm8         ; o16 0F AC /r ib      [386]
    SHRD r/m32,reg32,imm8         ; o32 0F AC /r ib      [386]
    SHRD r/m16,reg16,CL           ; o16 0F AD /r         [386]
    SHRD r/m32,reg32,CL           ; o32 0F AD /r         [386]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">SHLD</tt> performs a
            double-precision left shift. It notionally places its
            second operand to the right of its first, then shifts
            the entire bit string thus generated to the left by a
            number of bits specified in the third operand. It then
            updates only the <span class="emphasis"><i class=
            "EMPHASIS">first</i></span> operand according to the
            result of this. The second operand is not modified.</p>
          </li>

          <li>
            <p><tt class="LITERAL">SHRD</tt> performs the
            corresponding right shift: it notionally places the
            second operand to the <span class="emphasis"><i class=
            "EMPHASIS">left</i></span> of the first, shifts the
            whole bit string right, and updates only the first
            operand.</p>
          </li>
        </ul>

        <p>For example, if <tt class="REGISTER">EAX</tt> holds <tt
        class="LITERAL">0x01234567</tt> and <tt class=
        "REGISTER">EBX</tt> holds <tt class=
        "LITERAL">0x89ABCDEF</tt>, then the instruction <tt class=
        "LITERAL">SHLD EAX,EBX,4</tt> would update <tt class=
        "REGISTER">EAX</tt> to hold <tt class=
        "LITERAL">0x12345678</tt>. Under the same conditions, <tt
        class="LITERAL">SHRD EAX,EBX,4</tt> would update <tt class=
        "REGISTER">EAX</tt> to hold <tt class=
        "LITERAL">0xF0123456</tt>.</p>

        <p>The number of bits to shift by is given by the third
        operand. Only the bottom five bits of the shift count are
        considered.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SMSW">B.4.136 <tt
        class="LITERAL">SMSW</tt>: Store Machine Status
        Word</a></h2>
<pre class="SCREEN">
    SMSW r/m16                    ; 0F 01 /4             [286,PRIV]
</pre>

        <p><tt class="LITERAL">SMSW</tt> stores the bottom half of
        the <tt class="LITERAL">CR0</tt> control register (or the
        Machine Status Word, on 286 processors) into the
        destination operand. See also <tt class="LITERAL">LMSW</tt>
        (<a href="inst-ref-general.html#INST-REF-LMSW">Section
        B.4.96</a>).</p>

        <p>For 32-bit code, this would use the low 16-bits of the
        specified register (or a 16 bit memory location), without
        needing an operand size override byte.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-STC">B.4.137 <tt class=
        "LITERAL">STC</tt>, <tt class="LITERAL">STD</tt>, <tt
        class="LITERAL">STI</tt>: Set Flags</a></h2>
<pre class="SCREEN">
    STC                           ; F9                   [8086]
    STD                           ; FD                   [8086]
    STI                           ; FB                   [8086]
</pre>

        <p>These instructions set various flags. <tt class=
        "LITERAL">STC</tt> sets the carry flag; <tt class=
        "LITERAL">STD</tt> sets the direction flag; and <tt class=
        "LITERAL">STI</tt> sets the interrupt flag (thus enabling
        interrupts).</p>

        <p>To clear the carry, direction, or interrupt flags, use
        the <tt class="LITERAL">CLC</tt>, <tt class=
        "LITERAL">CLD</tt> and <tt class="LITERAL">CLI</tt>
        instructions (<a href=
        "inst-ref-general.html#INST-REF-CLC">Section B.4.12</a>).
        To invert the carry flag, use <tt class="LITERAL">CMC</tt>
        (<a href="inst-ref-general.html#INST-REF-CMC">Section
        B.4.14</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-STOSB">B.4.138 <tt
        class="LITERAL">STOSB</tt>, <tt class="LITERAL">STOSW</tt>,
        <tt class="LITERAL">STOSD</tt>: Store Byte to
        String</a></h2>
<pre class="SCREEN">
    STOSB                         ; AA                   [8086]
    STOSW                         ; o16 AB               [8086]
    STOSD                         ; o32 AB               [386]
</pre>

        <p><tt class="LITERAL">STOSB</tt> stores the byte in <tt
        class="REGISTER">AL</tt> at <tt class="LITERAL">[<tt class=
        "REGISTER">ES</tt>:DI]</tt> or <tt class="LITERAL">[<tt
        class="REGISTER">ES</tt>:<tt class=
        "REGISTER">EDI</tt>]</tt>, and sets the flags accordingly.
        It then increments or decrements (depending on the
        direction flag: increments if the flag is clear, decrements
        if it is set) <tt class="REGISTER">DI</tt> (or <tt class=
        "REGISTER">EDI</tt>).</p>

        <p>The register used is <tt class="REGISTER">DI</tt> if the
        address size is 16 bits, and <tt class="REGISTER">EDI</tt>
        if it is 32 bits. If you need to use an address size not
        equal to the current <tt class="LITERAL">BITS</tt> setting,
        you can use an explicit <tt class="LITERAL">a16</tt> or <tt
        class="LITERAL">a32</tt> prefix.</p>

        <p>Segment override prefixes have no effect for this
        instruction: the use of <tt class="REGISTER">ES</tt> for
        the store to <tt class="LITERAL">[DI]</tt> or <tt class=
        "LITERAL">[<tt class="REGISTER">EDI</tt>]</tt> cannot be
        overridden.</p>

        <p><tt class="LITERAL">STOSW</tt> and <tt class=
        "LITERAL">STOSD</tt> work in the same way, but they store
        the word in <tt class="REGISTER">AX</tt> or the doubleword
        in <tt class="REGISTER">EAX</tt> instead of the byte in <tt
        class="REGISTER">AL</tt>, and increment or decrement the
        addressing registers by 2 or 4 instead of 1.</p>

        <p>The <tt class="LITERAL">REP</tt> prefix may be used to
        repeat the instruction <tt class="REGISTER">CX</tt> (or <tt
        class="REGISTER">ECX</tt> - again, the address size chooses
        which) times.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-STR">B.4.139 <tt class=
        "LITERAL">STR</tt>: Store Task Register</a></h2>
<pre class="SCREEN">
    STR r/m16                     ; 0F 00 /1             [286,PRIV]
</pre>

        <p><tt class="LITERAL">STR</tt> stores the segment selector
        corresponding to the contents of the Task Register into its
        operand. When the operand size is a 16-bit register, the
        upper 16-bits are cleared to 0s. When the destination
        operand is a memory location, 16 bits are written
        regardless of the operand size.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SUB">B.4.140 <tt class=
        "LITERAL">SUB</tt>: Subtract Integers</a></h2>
<pre class="SCREEN">
    SUB r/m8,reg8                 ; 28 /r                [8086]
    SUB r/m16,reg16               ; o16 29 /r            [8086]
    SUB r/m32,reg32               ; o32 29 /r            [386]
    
    SUB reg8,r/m8                 ; 2A /r                [8086]
    SUB reg16,r/m16               ; o16 2B /r            [8086]
    SUB reg32,r/m32               ; o32 2B /r            [386]
    
    SUB r/m8,imm8                 ; 80 /5 ib             [8086]
    SUB r/m16,imm16               ; o16 81 /5 iw         [8086]
    SUB r/m32,imm32               ; o32 81 /5 id         [386]
    
    SUB r/m16,imm8                ; o16 83 /5 ib         [8086]
    SUB r/m32,imm8                ; o32 83 /5 ib         [386]
    
    SUB AL,imm8                   ; 2C ib                [8086]
    SUB AX,imm16                  ; o16 2D iw            [8086]
    SUB EAX,imm32                 ; o32 2D id            [386]
</pre>

        <p><tt class="LITERAL">SUB</tt> performs integer
        subtraction: it subtracts its second operand from its
        first, and leaves the result in its destination (first)
        operand. The flags are set according to the result of the
        operation: in particular, the carry flag is affected and
        can be used by a subsequent <tt class="LITERAL">SBB</tt>
        instruction (<a href=
        "inst-ref-general.html#INST-REF-SBB">Section
        B.4.129</a>).</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SYSCALL">B.4.141 <tt
        class="LITERAL">SYSCALL</tt>: Call Operating
        System</a></h2>
<pre class="SCREEN">
    SYSCALL                       ; 0F 05                [P6,AMD]
</pre>

        <p><tt class="LITERAL">SYSCALL</tt> provides a fast method
        of transferring control to a fixed entry point in an
        operating system.</p>

        <ul>
          <li>
            <p>The <tt class="REGISTER">EIP</tt> register is copied
            into the <tt class="REGISTER">ECX</tt> register.</p>
          </li>

          <li>
            <p>Bits [31-0] of the 64-bit SYSCALL/SYSRET Target
            Address Register (<tt class="LITERAL">STAR</tt>) are
            copied into the <tt class="REGISTER">EIP</tt>
            register.</p>
          </li>

          <li>
            <p>Bits [47-32] of the <tt class="LITERAL">STAR</tt>
            register specify the selector that is copied into the
            <tt class="REGISTER">CS</tt> register.</p>
          </li>

          <li>
            <p>Bits [47-32]+1000b of the <tt class=
            "LITERAL">STAR</tt> register specify the selector that
            is copied into the <tt class="REGISTER">SS</tt>
            register.</p>
          </li>
        </ul>

        <p>The <tt class="REGISTER">CS</tt> and <tt class=
        "REGISTER">SS</tt> registers should not be modified by the
        operating system between the execution of the <tt class=
        "LITERAL">SYSCALL</tt> instruction and its corresponding
        <tt class="LITERAL">SYSRET</tt> instruction.</p>

        <p>For more information, see the <span class=
        "QUOTE">"SYSCALL and SYSRET Instruction
        Specification"</span> (AMD document number 21086.pdf).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SYSENTER">B.4.142 <tt
        class="LITERAL">SYSENTER</tt>: Fast System Call</a></h2>
<pre class="SCREEN">
    SYSENTER                      ; 0F 34                [P6]
</pre>

        <p><tt class="LITERAL">SYSENTER</tt> executes a fast call
        to a level 0 system procedure or routine. Before using this
        instruction, various MSRs need to be set up:</p>

        <ul>
          <li>
            <p><tt class="LITERAL">SYSENTER_CS_MSR</tt> contains
            the 32-bit segment selector for the privilege level 0
            code segment. (This value is also used to compute the
            segment selector of the privilege level 0 stack
            segment.)</p>
          </li>

          <li>
            <p><tt class="LITERAL">SYSENTER_EIP_MSR</tt> contains
            the 32-bit offset into the privilege level 0 code
            segment to the first instruction of the selected
            operating procedure or routine.</p>
          </li>

          <li>
            <p><tt class="LITERAL">SYSENTER_ESP_MSR</tt> contains
            the 32-bit stack pointer for the privilege level 0
            stack.</p>
          </li>
        </ul>

        <p><tt class="LITERAL">SYSENTER</tt> performs the following
        sequence of operations:</p>

        <ul>
          <li>
            <p>Loads the segment selector from the <tt class=
            "LITERAL">SYSENTER_CS_MSR</tt> into the <tt class=
            "REGISTER">CS</tt> register.</p>
          </li>

          <li>
            <p>Loads the instruction pointer from the <tt class=
            "LITERAL">SYSENTER_EIP_MSR</tt> into the <tt class=
            "REGISTER">EIP</tt> register.</p>
          </li>

          <li>
            <p>Adds 8 to the value in <tt class=
            "LITERAL">SYSENTER_CS_MSR</tt> and loads it into the
            <tt class="REGISTER">SS</tt> register.</p>
          </li>

          <li>
            <p>Loads the stack pointer from the <tt class=
            "LITERAL">SYSENTER_ESP_MSR</tt> into the <tt class=
            "REGISTER">ESP</tt> register.</p>
          </li>

          <li>
            <p>Switches to privilege level 0.</p>
          </li>

          <li>
            <p>Clears the <tt class="REGISTER">VM</tt> flag in the
            <tt class="LITERAL">EFLAGS</tt> register, if the flag
            is set.</p>
          </li>

          <li>
            <p>Begins executing the selected system procedure.</p>
          </li>
        </ul>

        <p>In particular, note that this instruction des not save
        the values of <tt class="REGISTER">CS</tt> or <tt class=
        "REGISTER">EIP</tt>. If you need to return to the calling
        code, you need to write your code to cater for this.</p>

        <p>For more information, see the <span class="QUOTE">"Intel
        Architecture Software Developer's Manual, Volume
        2"</span>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SYSEXIT">B.4.143 <tt
        class="LITERAL">SYSEXIT</tt>: Fast Return From System
        Call</a></h2>
<pre class="SCREEN">
    SYSEXIT                       ; 0F 35                [P6,PRIV]
</pre>

        <p><tt class="LITERAL">SYSEXIT</tt> executes a fast return
        to privilege level 3 user code. This instruction is a
        companion instruction to the <tt class=
        "LITERAL">SYSENTER</tt> instruction, and can only be
        executed by privilege level 0 code. Various registers need
        to be set up before calling this instruction:</p>

        <ul>
          <li>
            <p><tt class="LITERAL">SYSENTER_CS_MSR</tt> contains
            the 32-bit segment selector for the privilege level 0
            code segment in which the processor is currently
            executing. (This value is used to compute the segment
            selectors for the privilege level 3 code and stack
            segments.)</p>
          </li>

          <li>
            <p><tt class="REGISTER">EDX</tt> contains the 32-bit
            offset into the privilege level 3 code segment to the
            first instruction to be executed in the user code.</p>
          </li>

          <li>
            <p><tt class="REGISTER">ECX</tt> contains the 32-bit
            stack pointer for the privilege level 3 stack.</p>
          </li>
        </ul>

        <p><tt class="LITERAL">SYSEXIT</tt> performs the following
        sequence of operations:</p>

        <ul>
          <li>
            <p>Adds 16 to the value in <tt class=
            "LITERAL">SYSENTER_CS_MSR</tt> and loads the sum into
            the <tt class="REGISTER">CS</tt> selector register.</p>
          </li>

          <li>
            <p>Loads the instruction pointer from the <tt class=
            "REGISTER">EDX</tt> register into the <tt class=
            "REGISTER">EIP</tt> register.</p>
          </li>

          <li>
            <p>Adds 24 to the value in <tt class=
            "LITERAL">SYSENTER_CS_MSR</tt> and loads the sum into
            the <tt class="REGISTER">SS</tt> selector register.</p>
          </li>

          <li>
            <p>Loads the stack pointer from the <tt class=
            "REGISTER">ECX</tt> register into the <tt class=
            "REGISTER">ESP</tt> register.</p>
          </li>

          <li>
            <p>Switches to privilege level 3.</p>
          </li>

          <li>
            <p>Begins executing the user code at the <tt class=
            "REGISTER">EIP</tt> address.</p>
          </li>
        </ul>

        <p>For more information on the use of the <tt class=
        "LITERAL">SYSENTER</tt> and <tt class=
        "LITERAL">SYSEXIT</tt> instructions, see the <span class=
        "QUOTE">"Intel Architecture Software Developer's Manual,
        Volume 2"</span>.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-SYSRET">B.4.144 <tt
        class="LITERAL">SYSRET</tt>: Return From Operating
        System</a></h2>
<pre class="SCREEN">
    SYSRET                        ; 0F 07                [P6,AMD,PRIV]
</pre>

        <p><tt class="LITERAL">SYSRET</tt> is the return
        instruction used in conjunction with the <tt class=
        "LITERAL">SYSCALL</tt> instruction to provide fast
        entry/exit to an operating system.</p>

        <ul>
          <li>
            <p>The <tt class="REGISTER">ECX</tt> register, which
            points to the next sequential instruction after the
            corresponding <tt class="LITERAL">SYSCALL</tt>
            instruction, is copied into the <tt class=
            "REGISTER">EIP</tt> register.</p>
          </li>

          <li>
            <p>Bits [63-48] of the <tt class="LITERAL">STAR</tt>
            register specify the selector that is copied into the
            <tt class="REGISTER">CS</tt> register.</p>
          </li>

          <li>
            <p>Bits [63-48]+1000b of the <tt class=
            "LITERAL">STAR</tt> register specify the selector that
            is copied into the <tt class="REGISTER">SS</tt>
            register.</p>
          </li>

          <li>
            <p>Bits [1-0] of the <tt class="REGISTER">SS</tt>
            register are set to 11b (RPL of 3) regardless of the
            value of bits [49-48] of the <tt class=
            "LITERAL">STAR</tt> register.</p>
          </li>
        </ul>

        <p>The <tt class="REGISTER">CS</tt> and <tt class=
        "REGISTER">SS</tt> registers should not be modified by the
        operating system between the execution of the <tt class=
        "LITERAL">SYSCALL</tt> instruction and its corresponding
        <tt class="LITERAL">SYSRET</tt> instruction.</p>

        <p>For more information, see the <span class=
        "QUOTE">"SYSCALL and SYSRET Instruction
        Specification"</span> (AMD document number 21086.pdf).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-TEST">B.4.145 <tt
        class="LITERAL">TEST</tt>: Test Bits (notional bitwise
        AND)</a></h2>
<pre class="SCREEN">
    TEST r/m8,reg8                ; 84 /r                [8086]
    TEST r/m16,reg16              ; o16 85 /r            [8086]
    TEST r/m32,reg32              ; o32 85 /r            [386]
    
    TEST r/m8,imm8                ; F6 /0 ib             [8086]
    TEST r/m16,imm16              ; o16 F7 /0 iw         [8086]
    TEST r/m32,imm32              ; o32 F7 /0 id         [386]
    
    TEST AL,imm8                  ; A8 ib                [8086]
    TEST AX,imm16                 ; o16 A9 iw            [8086]
    TEST EAX,imm32                ; o32 A9 id            [386]
</pre>

        <p><tt class="LITERAL">TEST</tt> performs a <span class=
        "QUOTE">"mental"</span> bitwise AND of its two operands,
        and affects the flags as if the operation had taken place,
        but does not store the result of the operation
        anywhere.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-VERR">B.4.146 <tt
        class="LITERAL">VERR</tt>, <tt class="LITERAL">VERW</tt>:
        Verify Segment Readability/Writability</a></h2>
<pre class="SCREEN">
    VERR r/m16                    ; 0F 00 /4             [286,PRIV]
    
    VERW r/m16                    ; 0F 00 /5             [286,PRIV]
</pre>

        <ul>
          <li>
            <p><tt class="LITERAL">VERR</tt> sets the zero flag if
            the segment specified by the selector in its operand
            can be read from at the current privilege level.</p>
          </li>

          <li>
            <p><tt class="LITERAL">VERW</tt> sets the zero flag if
            the segment can be written.</p>
          </li>
        </ul>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-WAIT">B.4.147 <tt
        class="LITERAL">WAIT</tt>: Wait for Floating-Point
        Processor</a></h2>
<pre class="SCREEN">
    WAIT                          ; 9B                   [8086]
    FWAIT                         ; 9B                   [8086]
</pre>

        <p><tt class="LITERAL">WAIT</tt>, on 8086 systems with a
        separate 8087 FPU, waits for the FPU to have finished any
        operation it is engaged in before continuing main processor
        operations, so that (for example) an FPU store to main
        memory can be guaranteed to have completed before the CPU
        tries to read the result back out.</p>

        <p>On higher processors, <tt class="LITERAL">WAIT</tt> is
        unnecessary for this purpose, and it has the alternative
        purpose of ensuring that any pending unmasked FPU
        exceptions have happened before execution continues.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-WBINVD">B.4.148 <tt
        class="LITERAL">WBINVD</tt>: Write Back and Invalidate
        Cache</a></h2>
<pre class="SCREEN">
    WBINVD                        ; 0F 09                [486]
</pre>

        <p><tt class="LITERAL">WBINVD</tt> invalidates and empties
        the processor's internal caches, and causes the processor
        to instruct external caches to do the same. It writes the
        contents of the caches back to memory first, so no data is
        lost. To flush the caches quickly without bothering to
        write the data back first, use <tt class=
        "LITERAL">INVD</tt> (<a href=
        "inst-ref-general.html#INST-REF-INVD">Section
        B.4.83</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-WRMSR">B.4.149 <tt
        class="LITERAL">WRMSR</tt>: Write Model-Specific
        Registers</a></h2>
<pre class="SCREEN">
    WRMSR                         ; 0F 30                [PENT]
</pre>

        <p><tt class="LITERAL">WRMSR</tt> writes the value in <tt
        class="LITERAL"><tt class="REGISTER">EDX</tt>:<tt class=
        "REGISTER">EAX</tt></tt> to the processor Model-Specific
        Register (MSR) whose index is stored in <tt class=
        "REGISTER">ECX</tt>. See also <tt class=
        "LITERAL">RDMSR</tt> (<a href=
        "inst-ref-general.html#INST-REF-RDMSR">Section
        B.4.120</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-XADD">B.4.150 <tt
        class="LITERAL">XADD</tt>: Exchange and Add</a></h2>
<pre class="SCREEN">
    XADD r/m8,reg8                ; 0F C0 /r             [486]
    XADD r/m16,reg16              ; o16 0F C1 /r         [486]
    XADD r/m32,reg32              ; o32 0F C1 /r         [486]
</pre>

        <p><tt class="LITERAL">XADD</tt> exchanges the values in
        its two operands, and then adds them together and writes
        the result into the destination (first) operand. This
        instruction can be used with a <tt class=
        "LITERAL">LOCK</tt> prefix for multi-processor
        synchronisation purposes.</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-XCHG">B.4.151 <tt
        class="LITERAL">XCHG</tt>: Exchange</a></h2>
<pre class="SCREEN">
    XCHG reg8,r/m8                ; 86 /r                [8086]
    XCHG reg16,r/m8               ; o16 87 /r            [8086]
    XCHG reg32,r/m32              ; o32 87 /r            [386]
    
    XCHG r/m8,reg8                ; 86 /r                [8086]
    XCHG r/m16,reg16              ; o16 87 /r            [8086]
    XCHG r/m32,reg32              ; o32 87 /r            [386]
    
    XCHG AX,reg16                 ; o16 90+r             [8086]
    XCHG EAX,reg32                ; o32 90+r             [386]
    XCHG reg16,AX                 ; o16 90+r             [8086]
    XCHG reg32,EAX                ; o32 90+r             [386]
</pre>

        <p><tt class="LITERAL">XCHG</tt> exchanges the values in
        its two operands. It can be used with a <tt class=
        "LITERAL">LOCK</tt> prefix for purposes of multi-processor
        synchronisation.</p>

        <p><tt class="LITERAL">XCHG AX,AX</tt> or <tt class=
        "LITERAL">XCHG EAX,EAX</tt> (depending on the <tt class=
        "LITERAL">BITS</tt> setting) generates the opcode <tt
        class="LITERAL">90h</tt>, and so is a synonym for <tt
        class="LITERAL">NOP</tt> (<a href=
        "inst-ref-general.html#INST-REF-NOP">Section
        B.4.107</a>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-XLATB">B.4.152 <tt
        class="LITERAL">XLATB</tt>: Translate Byte in Lookup
        Table</a></h2>
<pre class="SCREEN">
    XLAT                          ; D7                   [8086]
    XLATB                         ; D7                   [8086]
</pre>

        <p><tt class="LITERAL">XLATB</tt> adds the value in <tt
        class="REGISTER">AL</tt>, treated as an unsigned byte, to
        <tt class="REGISTER">BX</tt> or <tt class=
        "REGISTER">EBX</tt>, and loads the byte from the resulting
        address (in the segment specified by <tt class=
        "REGISTER">DS</tt>) back into <tt class=
        "REGISTER">AL</tt>.</p>

        <p>The base register used is <tt class="REGISTER">BX</tt>
        if the address size is 16 bits, and <tt class=
        "REGISTER">EBX</tt> if it is 32 bits. If you need to use an
        address size not equal to the current <tt class=
        "LITERAL">BITS</tt> setting, you can use an explicit <tt
        class="LITERAL">a16</tt> or <tt class="LITERAL">a32</tt>
        prefix.</p>

        <p>The segment register used to load from <tt class=
        "LITERAL">[<tt class="REGISTER">BX</tt>+<tt class=
        "REGISTER">AL</tt>]</tt> or <tt class="LITERAL">[<tt class=
        "REGISTER">EBX</tt>+<tt class="REGISTER">AL</tt>]</tt> can
        be overridden by using a segment register name as a prefix
        (for example, <tt class="LITERAL">es xlatb</tt>).</p>
      </div>

      <div class="SECT2">
        <h2 class="SECT2"><a name="INST-REF-XOR">B.4.153 <tt class=
        "LITERAL">XOR</tt>: Bitwise Exclusive OR</a></h2>
<pre class="SCREEN">
    XOR r/m8,reg8                 ; 30 /r                [8086]
    XOR r/m16,reg16               ; o16 31 /r            [8086]
    XOR r/m32,reg32               ; o32 31 /r            [386]
    
    XOR reg8,r/m8                 ; 32 /r                [8086]
    XOR reg16,r/m16               ; o16 33 /r            [8086]
    XOR reg32,r/m32               ; o32 33 /r            [386]
    
    XOR r/m8,imm8                 ; 80 /6 ib             [8086]
    XOR r/m16,imm16               ; o16 81 /6 iw         [8086]
    XOR r/m32,imm32               ; o32 81 /6 id         [386]
    
    XOR r/m16,imm8                ; o16 83 /6 ib         [8086]
    XOR r/m32,imm8                ; o32 83 /6 ib         [386]
    
    XOR AL,imm8                   ; 34 ib                [8086]
    XOR AX,imm16                  ; o16 35 iw            [8086]
    XOR EAX,imm32                 ; o32 35 id            [386]
</pre>

        <p><tt class="LITERAL">XOR</tt> performs a bitwise XOR
        operation between its two operands (i.e. each bit of the
        result is 1 if and only if exactly one of the corresponding
        bits of the two inputs was 1), and stores the result in the
        destination (first) operand.</p>

        <p>In the forms with an 8-bit immediate second operand and
        a longer first operand, the second operand is considered to
        be signed, and is sign-extended to the length of the first
        operand. In these cases, the <tt class="LITERAL">BYTE</tt>
        qualifier is necessary to force NASM to generate this form
        of the instruction.</p>

        <p>The <tt class="REGISTER">MMX</tt> instruction <tt class=
        "LITERAL">PXOR</tt> (see <a href=
        "inst-ref-simd.html#INST-REF-PXOR">Section B.5.64</a>)
        performs the same operation on the 64-bit <tt class=
        "REGISTER">MMX</tt> registers.</p>
      </div>
    </div>

    <div class="NAVFOOTER">
      <hr align="LEFT" width="100%">

      <table summary="Footer navigation table" width="100%" border=
      "0" cellpadding="0" cellspacing="0">
        <tr>
          <td width="33%" align="left" valign="top"><a href=
          "inst-ref-flags.html" accesskey="P">Prev</a></td>

          <td width="34%" align="center" valign="top"><a href=
          "index.html" accesskey="H">Home</a></td>

          <td width="33%" align="right" valign="top"><a href=
          "inst-ref-simd.html" accesskey="N">Next</a></td>
        </tr>

        <tr>
          <td width="33%" align="left" valign="top">Key to
          Instruction Flags</td>

          <td width="34%" align="center" valign="top"><a href=
          "inst-ref.html" accesskey="U">Up</a></td>

          <td width="33%" align="right" valign="top">SIMD
          Instructions (MMX, SSE)</td>
        </tr>
      </table>
    </div>
  </body>
</html>

